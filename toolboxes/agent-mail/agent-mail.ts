#!/usr/bin/env bun
// @generated by mcporter@0.7.3 on 2026-01-07T18:25:01.566Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "agent-mail",
  "description": "You are the MCP Agent Mail coordination server. Provide message routing, coordination tooling, and project context to cooperating agents.",
  "command": {
    "kind": "http",
    "url": "http://127.0.0.1:8765/mcp/"
  }
} as const;
const embeddedSchemas = {
  "health_check": {
    "type": "object",
    "properties": {}
  },
  "ensure_project": {
    "type": "object",
    "properties": {
      "human_key": {
        "type": "string"
      },
      "identity_mode": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "human_key"
    ]
  },
  "register_agent": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "program": {
        "type": "string"
      },
      "model": {
        "type": "string"
      },
      "name": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "task_description": {
        "default": "",
        "type": "string"
      },
      "attachments_policy": {
        "default": "auto",
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "program",
      "model"
    ]
  },
  "whois": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "include_recent_commits": {
        "default": true,
        "type": "boolean"
      },
      "commit_limit": {
        "default": 5,
        "type": "integer"
      }
    },
    "required": [
      "project_key",
      "agent_name"
    ]
  },
  "create_agent_identity": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "program": {
        "type": "string"
      },
      "model": {
        "type": "string"
      },
      "name_hint": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "task_description": {
        "default": "",
        "type": "string"
      },
      "attachments_policy": {
        "default": "auto",
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "program",
      "model"
    ]
  },
  "send_message": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "sender_name": {
        "type": "string"
      },
      "to": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "subject": {
        "type": "string"
      },
      "body_md": {
        "type": "string"
      },
      "cc": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "bcc": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "attachment_paths": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "convert_images": {
        "anyOf": [
          {
            "type": "boolean"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "importance": {
        "default": "normal",
        "type": "string"
      },
      "ack_required": {
        "default": false,
        "type": "boolean"
      },
      "thread_id": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "auto_contact_if_blocked": {
        "default": false,
        "type": "boolean"
      }
    },
    "required": [
      "project_key",
      "sender_name",
      "to",
      "subject",
      "body_md"
    ]
  },
  "reply_message": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "message_id": {
        "type": "integer"
      },
      "sender_name": {
        "type": "string"
      },
      "body_md": {
        "type": "string"
      },
      "to": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "cc": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "bcc": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "subject_prefix": {
        "default": "Re:",
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "message_id",
      "sender_name",
      "body_md"
    ]
  },
  "request_contact": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "from_agent": {
        "type": "string"
      },
      "to_agent": {
        "type": "string"
      },
      "to_project": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "reason": {
        "default": "",
        "type": "string"
      },
      "ttl_seconds": {
        "default": 604800,
        "type": "integer"
      },
      "register_if_missing": {
        "default": true,
        "type": "boolean"
      },
      "program": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "model": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "task_description": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "from_agent",
      "to_agent"
    ]
  },
  "respond_contact": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "to_agent": {
        "type": "string"
      },
      "from_agent": {
        "type": "string"
      },
      "accept": {
        "type": "boolean"
      },
      "ttl_seconds": {
        "default": 2592000,
        "type": "integer"
      },
      "from_project": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "to_agent",
      "from_agent",
      "accept"
    ]
  },
  "list_contacts": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "agent_name"
    ]
  },
  "set_contact_policy": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "policy": {
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "policy"
    ]
  },
  "fetch_inbox": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "limit": {
        "default": 20,
        "type": "integer"
      },
      "urgent_only": {
        "default": false,
        "type": "boolean"
      },
      "include_bodies": {
        "default": false,
        "type": "boolean"
      },
      "since_ts": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "agent_name"
    ]
  },
  "mark_message_read": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "message_id": {
        "type": "integer"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "message_id"
    ]
  },
  "acknowledge_message": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "message_id": {
        "type": "integer"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "message_id"
    ]
  },
  "macro_start_session": {
    "type": "object",
    "properties": {
      "human_key": {
        "type": "string"
      },
      "program": {
        "type": "string"
      },
      "model": {
        "type": "string"
      },
      "task_description": {
        "default": "",
        "type": "string"
      },
      "agent_name": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "file_reservation_paths": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "file_reservation_reason": {
        "default": "macro-session",
        "type": "string"
      },
      "file_reservation_ttl_seconds": {
        "default": 3600,
        "type": "integer"
      },
      "inbox_limit": {
        "default": 10,
        "type": "integer"
      }
    },
    "required": [
      "human_key",
      "program",
      "model"
    ]
  },
  "macro_prepare_thread": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "thread_id": {
        "type": "string"
      },
      "program": {
        "type": "string"
      },
      "model": {
        "type": "string"
      },
      "agent_name": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "task_description": {
        "default": "",
        "type": "string"
      },
      "register_if_missing": {
        "default": true,
        "type": "boolean"
      },
      "include_examples": {
        "default": true,
        "type": "boolean"
      },
      "inbox_limit": {
        "default": 10,
        "type": "integer"
      },
      "include_inbox_bodies": {
        "default": false,
        "type": "boolean"
      },
      "llm_mode": {
        "default": true,
        "type": "boolean"
      },
      "llm_model": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "thread_id",
      "program",
      "model"
    ]
  },
  "macro_file_reservation_cycle": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "paths": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "ttl_seconds": {
        "default": 3600,
        "type": "integer"
      },
      "exclusive": {
        "default": true,
        "type": "boolean"
      },
      "reason": {
        "default": "macro-file_reservation",
        "type": "string"
      },
      "auto_release": {
        "default": false,
        "type": "boolean"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "paths"
    ]
  },
  "macro_contact_handshake": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "requester": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "target": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "reason": {
        "default": "",
        "type": "string"
      },
      "ttl_seconds": {
        "default": 604800,
        "type": "integer"
      },
      "auto_accept": {
        "default": false,
        "type": "boolean"
      },
      "welcome_subject": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "welcome_body": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "to_project": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "agent_name": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "to_agent": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "register_if_missing": {
        "default": true,
        "type": "boolean"
      },
      "program": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "model": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "task_description": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "thread_id": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key"
    ]
  },
  "search_messages": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "query": {
        "type": "string"
      },
      "limit": {
        "default": 20,
        "type": "integer"
      }
    },
    "required": [
      "project_key",
      "query"
    ]
  },
  "summarize_thread": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "thread_id": {
        "type": "string"
      },
      "include_examples": {
        "default": false,
        "type": "boolean"
      },
      "llm_mode": {
        "default": true,
        "type": "boolean"
      },
      "llm_model": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "per_thread_limit": {
        "default": 50,
        "type": "integer"
      }
    },
    "required": [
      "project_key",
      "thread_id"
    ]
  },
  "install_precommit_guard": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "code_repo_path": {
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "code_repo_path"
    ]
  },
  "uninstall_precommit_guard": {
    "type": "object",
    "properties": {
      "code_repo_path": {
        "type": "string"
      }
    },
    "required": [
      "code_repo_path"
    ]
  },
  "file_reservation_paths": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "paths": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "ttl_seconds": {
        "default": 3600,
        "type": "integer"
      },
      "exclusive": {
        "default": true,
        "type": "boolean"
      },
      "reason": {
        "default": "",
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "paths"
    ]
  },
  "release_file_reservations": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "paths": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "file_reservation_ids": {
        "anyOf": [
          {
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "agent_name"
    ]
  },
  "force_release_file_reservation": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "file_reservation_id": {
        "type": "integer"
      },
      "notify_previous": {
        "default": true,
        "type": "boolean"
      },
      "note": {
        "default": "",
        "type": "string"
      }
    },
    "required": [
      "project_key",
      "agent_name",
      "file_reservation_id"
    ]
  },
  "renew_file_reservations": {
    "type": "object",
    "properties": {
      "project_key": {
        "type": "string"
      },
      "agent_name": {
        "type": "string"
      },
      "extend_seconds": {
        "default": 1800,
        "type": "integer"
      },
      "paths": {
        "anyOf": [
          {
            "items": {
              "type": "string"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      },
      "file_reservation_ids": {
        "anyOf": [
          {
            "items": {
              "type": "integer"
            },
            "type": "array"
          },
          {
            "type": "null"
          }
        ],
        "default": null
      }
    },
    "required": [
      "project_key",
      "agent_name"
    ]
  }
} as const;
const embeddedName = "agent-mail";
const embeddedDescription = "You are the MCP Agent Mail coordination server. Provide message routing, coordination tooling, and project context to cooperating agents.";
const generatorInfo = "Generated by mcporter@0.7.3 — https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "health-check",
    "description": "Return basic readiness information for the Agent Mail server.",
    "usage": "health-check [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "ensure-project",
    "description": "Idempotently create or ensure a project exists for the given human key.\n\nWhen to use\n-----------\n- First call in a workflow targeting a new repo/path identifier.\n- As a guard before registering agents or sending messages.\n\nHow it works\n------------\n- Validates that `human_key` is an absolute directory path (the agent's working directory).\n- Computes a stable slug from `human_key` (lowercased, safe characters) so\n  multiple agents can refer to the same project consistently.\n- Ensures DB row exists and that the on-disk archive is initialized\n  (e.g., `messages/`, `agents/`, `file_reservations/` directories).\n\nCRITICAL: Project Identity Rules\n---------------------------------\n- The `human_key` MUST be the absolute path to the agent's working directory\n- Two agents working in the SAME directory path are working on the SAME project\n- Example: Both agents in /data/projects/smartedgar_mcp → SAME project\n- Sibling projects are DIFFERENT directories (e.g., /data/projects/smartedgar_mcp\n  vs /data/projects/smartedgar_mcp_frontend)\n\nParameters\n----------\nhuman_key : str\n    The absolute path to the agent's working directory (e.g., \"/data/projects/backend\").\n    This MUST be an absolute path, not a relative path or arbitrary slug.\n    This is the canonical identifier for the project - all agents working in this\n    directory will share the same project identity.\n\nReturns\n-------\ndict\n    Minimal project descriptor: { id, slug, human_key, created_at }.\n\nExamples\n--------\nJSON-RPC:\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"2\",\n  \"method\": \"tools/call\",\n  \"params\": {\"name\": \"ensure_project\", \"arguments\": {\"human_key\": \"/data/projects/backend\"}}\n}\n```\n\nCommon mistakes\n---------------\n- Passing a relative path (e.g., \"./backend\") instead of an absolute path\n- Using arbitrary slugs instead of the actual working directory path\n- Creating separate projects for the same directory with different slugs\n\nIdempotency\n-----------\n- Safe to call multiple times. If the project already exists, the existing\n  record is returned and the archive is ensured on disk (no destructive changes).",
    "usage": "ensure-project --human-key <human-key> [--identity-mode <identity-mode>] [--raw <json>]",
    "flags": "--human-key <human-key> [--identity-mode <identity-mode>] [--raw <json>]"
  },
  {
    "name": "register-agent",
    "description": "Create or update an agent identity within a project and persist its profile to Git.\n\nWhen to use\n-----------\n- At the start of a coding session by any automated agent.\n- To update an existing agent's program/model/task metadata and bump last_active.\n\nSemantics\n---------\n- If `name` is omitted, a random adjective+noun name is auto-generated.\n- Reusing the same `name` updates the profile (program/model/task) and\n  refreshes `last_active_ts`.\n- A `profile.json` file is written under `agents/<Name>/` in the project archive.\n\nCRITICAL: Agent Naming Rules\n-----------------------------\n- Agent names MUST be randomly generated adjective+noun combinations\n- Examples: \"GreenLake\", \"BlueDog\", \"RedStone\", \"PurpleBear\"\n- Names should be unique, easy to remember, and NOT descriptive\n- INVALID examples: \"BackendHarmonizer\", \"DatabaseMigrator\", \"UIRefactorer\"\n- The whole point: names should be memorable identifiers, not role descriptions\n- Best practice: Omit the `name` parameter to auto-generate a valid name\n\nParameters\n----------\nproject_key : str\n    The same human key you passed to `ensure_project` (or equivalent identifier).\nprogram : str\n    The agent program (e.g., \"codex-cli\", \"claude-code\").\nmodel : str\n    The underlying model (e.g., \"gpt5-codex\", \"opus-4.1\").\nname : Optional[str]\n    MUST be a valid adjective+noun combination if provided (e.g., \"BlueLake\").\n    If omitted, a random valid name is auto-generated (RECOMMENDED).\n    Names are unique per project; passing the same name updates the profile.\ntask_description : str\n    Short description of current focus (shows up in directory listings).\n\nReturns\n-------\ndict\n    { id, name, program, model, task_description, inception_ts, last_active_ts, project_id }\n\nExamples\n--------\nRegister with auto-generated name (RECOMMENDED):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"method\":\"tools/call\",\"params\":{\"name\":\"register_agent\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"codex-cli\",\"model\":\"gpt5-codex\",\"task_description\":\"Auth refactor\"\n}}}\n```\n\nRegister with explicit valid name:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"4\",\"method\":\"tools/call\",\"params\":{\"name\":\"register_agent\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"claude-code\",\"model\":\"opus-4.1\",\"name\":\"BlueLake\",\"task_description\":\"Navbar redesign\"\n}}}\n```\n\nPitfalls\n--------\n- Names MUST match the adjective+noun format or an error will be raised\n- Names are case-insensitive unique. If you see \"already in use\", pick another or omit `name`.\n- Use the same `project_key` consistently across cooperating agents.",
    "usage": "register-agent --project-key <project-key> --program <program> --model <model> [--name <name>] [--task-description <task-description>] [--raw <json>]",
    "flags": "--project-key <project-key> --program <program> --model <model> [--name <name>] [--task-description <task-description>] [--raw <json>]"
  },
  {
    "name": "whois",
    "description": "Return enriched profile details for an agent, optionally including recent archive commits.\n\nDiscovery\n---------\nTo discover available agent names, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nagent_name : str\n    Agent name to look up (use resource://agents/{project_key} to discover names).\ninclude_recent_commits : bool\n    If true, include latest commits touching the project archive authored by the configured git author.\ncommit_limit : int\n    Maximum number of recent commits to include.\n\nReturns\n-------\ndict\n    Agent profile augmented with { recent_commits: [{hexsha, summary, authored_ts}] } when requested.",
    "usage": "whois --project-key <project-key> --agent-name <agent-name> [--include-recent-commits <include-recent-commits:true|false>] [--commit-limit <commit-limit:number>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> [--include-recent-commits <include-recent-commits:true|false>] [--commit-limit <commit-limit:number>] [--raw <json>]"
  },
  {
    "name": "create-agent-identity",
    "description": "Create a new, unique agent identity and persist its profile to Git.\n\nHow this differs from `register_agent`\n--------------------------------------\n- Always creates a new identity with a fresh unique name (never updates an existing one).\n- `name_hint`, if provided, MUST be a valid adjective+noun combination and must be available,\n  otherwise an error is raised. Without a hint, a random adjective+noun name is generated.\n\nCRITICAL: Agent Naming Rules\n-----------------------------\n- Agent names MUST be randomly generated adjective+noun combinations\n- Examples: \"GreenCastle\", \"BlueLake\", \"RedStone\", \"PurpleBear\"\n- Names should be unique, easy to remember, and NOT descriptive\n- INVALID examples: \"BackendHarmonizer\", \"DatabaseMigrator\", \"UIRefactorer\"\n- Best practice: Omit `name_hint` to auto-generate a valid name (RECOMMENDED)\n\nWhen to use\n-----------\n- Spawning a brand new worker agent that should not overwrite an existing profile.\n- Temporary task-specific identities (e.g., short-lived refactor assistants).\n\nReturns\n-------\ndict\n    { id, name, program, model, task_description, inception_ts, last_active_ts, project_id }\n\nExamples\n--------\nAuto-generate name (RECOMMENDED):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"c2\",\"method\":\"tools/call\",\"params\":{\"name\":\"create_agent_identity\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"claude-code\",\"model\":\"opus-4.1\"\n}}}\n```\n\nWith valid name hint:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"c1\",\"method\":\"tools/call\",\"params\":{\"name\":\"create_agent_identity\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"codex-cli\",\"model\":\"gpt5-codex\",\"name_hint\":\"GreenCastle\",\n  \"task_description\":\"DB migration spike\"\n}}}\n```",
    "usage": "create-agent-identity --project-key <project-key> --program <program> --model <model> [--name-hint <name-hint>] [--task-description <task-description>] [--raw <json>]",
    "flags": "--project-key <project-key> --program <program> --model <model> [--name-hint <name-hint>] [--task-description <task-description>] [--raw <json>]"
  },
  {
    "name": "send-message",
    "description": "Send a Markdown message to one or more recipients and persist canonical and mailbox copies to Git.\n\nDiscovery\n---------\nTo discover available agent names for recipients, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nWhat this does\n--------------\n- Stores message (and recipients) in the database; updates sender's activity\n- Writes a canonical `.md` under `messages/YYYY/MM/`\n- Writes sender outbox and per-recipient inbox copies\n- Optionally converts referenced images to WebP and embeds small images inline\n- Supports explicit attachments via `attachment_paths` in addition to inline references\n\nParameters\n----------\nproject_key : str\n    Project identifier (same used with `ensure_project`/`register_agent`).\nsender_name : str\n    Must match an agent registered in the project.\nto : list[str]\n    Primary recipients (agent names). At least one of to/cc/bcc must be non-empty.\nsubject : str\n    Short subject line that will be visible in inbox/outbox and search results.\nbody_md : str\n    GitHub-Flavored Markdown body. Image references can be file paths or data URIs.\ncc, bcc : Optional[list[str]]\n    Additional recipients by name.\nattachment_paths : Optional[list[str]]\n    Extra file paths to include as attachments; will be converted to WebP and stored.\nconvert_images : Optional[bool]\n    Overrides server default for image conversion/inlining. If None, server settings apply.\nimportance : str\n    One of {\"low\",\"normal\",\"high\",\"urgent\"} (free form tolerated; used by filters).\nack_required : bool\n    If true, recipients should call `acknowledge_message` after reading.\nthread_id : Optional[str]\n    If provided, message will be associated with an existing thread.\n\nReturns\n-------\ndict\n    {\n      \"deliveries\": [ { \"project\": str, \"payload\": { ... message payload ... } } ],\n      \"count\": int\n    }\n\nEdge cases\n----------\n- If no recipients are given, the call fails.\n- Unknown recipient names fail fast; register them first.\n- Non-absolute attachment paths are resolved relative to the project archive root.\n\nDo / Don't\n----------\nDo:\n- Keep subjects concise and specific (aim for ≤ 80 characters).\n- Use `thread_id` (or `reply_message`) to keep related discussion in a single thread.\n- Address only relevant recipients; use CC/BCC sparingly and intentionally.\n- Prefer Markdown links; attach images only when they materially aid understanding. The server\n  auto-converts images to WebP and may inline small images depending on policy.\n\nDon't:\n- Send large, repeated binaries—reuse prior attachments via `attachment_paths` when possible.\n- Change topics mid-thread—start a new thread for a new subject.\n- Broadcast to \"all\" agents unnecessarily—target just the agents who need to act.\n\nExamples\n--------\n1) Simple message:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"5\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Plan for /api/users\",\"body_md\":\"See below.\"\n}}}\n```\n\n2) Inline image (auto-convert to WebP and inline if small):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6a\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Diagram\",\"body_md\":\"![diagram](docs/flow.png)\",\"convert_images\":true\n}}}\n```\n\n3) Explicit attachments:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6b\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Screenshots\",\"body_md\":\"Please review.\",\"attachment_paths\":[\"shots/a.png\",\"shots/b.png\"]\n}}}\n```",
    "usage": "send-message --project-key <project-key> --sender-name <sender-name> --to <to:value1,value2> --subject <subject> --body-md <body-md> [--raw <json>]",
    "flags": "--project-key <project-key> --sender-name <sender-name> --to <to:value1,value2> --subject <subject> --body-md <body-md> [--raw <json>]"
  },
  {
    "name": "reply-message",
    "description": "Reply to an existing message, preserving or establishing a thread.\n\nBehavior\n--------\n- Inherits original `importance` and `ack_required` flags\n- `thread_id` is taken from the original message if present; otherwise, the original id is used\n- Subject is prefixed with `subject_prefix` if not already present\n- Defaults `to` to the original sender if not explicitly provided\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nmessage_id : int\n    The id of the message you are replying to.\nsender_name : str\n    Your agent name (must be registered in the project).\nbody_md : str\n    Reply body in Markdown.\nto, cc, bcc : Optional[list[str]]\n    Recipients by agent name. If omitted, `to` defaults to original sender.\nsubject_prefix : str\n    Prefix to apply (default \"Re:\"). Case-insensitive idempotent.\n\nDo / Don't\n----------\nDo:\n- Keep the subject focused; avoid topic drift within a thread.\n- Reply to the original sender unless new stakeholders are strictly required.\n- Preserve importance/ack flags from the original unless there is a clear reason to change.\n- Use CC for FYI only; BCC sparingly and with intention.\n\nDon't:\n- Change `thread_id` when continuing the same discussion.\n- Escalate to many recipients; prefer targeted replies and start a new thread for new topics.\n- Attach large binaries in replies unless essential; reference prior attachments where possible.\n\nReturns\n-------\ndict\n    Message payload including `thread_id` and `reply_to`.\n\nExamples\n--------\nMinimal reply to original sender:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6\",\"method\":\"tools/call\",\"params\":{\"name\":\"reply_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"message_id\":1234,\"sender_name\":\"BlueLake\",\n  \"body_md\":\"Questions about the migration plan...\"\n}}}\n```\n\nReply with explicit recipients and CC:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6c\",\"method\":\"tools/call\",\"params\":{\"name\":\"reply_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"message_id\":1234,\"sender_name\":\"BlueLake\",\n  \"body_md\":\"Looping ops.\",\"to\":[\"GreenCastle\"],\"cc\":[\"RedCat\"],\"subject_prefix\":\"RE:\"\n}}}\n```",
    "usage": "reply-message --project-key <project-key> --message-id <message-id:number> --sender-name <sender-name> --body-md <body-md> [--to <to>] [--raw <json>]",
    "flags": "--project-key <project-key> --message-id <message-id:number> --sender-name <sender-name> --body-md <body-md> [--to <to>] [--raw <json>]"
  },
  {
    "name": "request-contact",
    "description": "Request contact approval to message another agent.\n\nCreates (or refreshes) a pending AgentLink and sends a small ack_required intro message.\n\nDiscovery\n---------\nTo discover available agent names, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nfrom_agent : str\n    Your agent name (must be registered in the project).\nto_agent : str\n    Target agent name (use resource://agents/{project_key} to discover names).\nto_project : Optional[str]\n    Target project if different from your project (cross-project coordination).\nreason : str\n    Optional explanation for the contact request.\nttl_seconds : int\n    Time to live for the contact approval request (default: 7 days).",
    "usage": "request-contact --project-key <project-key> --from-agent <from-agent> --to-agent <to-agent> [--to-project <to-project>] [--reason <reason>] [--raw <json>]",
    "flags": "--project-key <project-key> --from-agent <from-agent> --to-agent <to-agent> [--to-project <to-project>] [--reason <reason>] [--raw <json>]"
  },
  {
    "name": "respond-contact",
    "description": "Approve or deny a contact request.",
    "usage": "respond-contact --project-key <project-key> --to-agent <to-agent> --from-agent <from-agent> --accept <accept:true|false> [--ttl-seconds <ttl-seconds:number>] [--raw <json>]",
    "flags": "--project-key <project-key> --to-agent <to-agent> --from-agent <from-agent> --accept <accept:true|false> [--ttl-seconds <ttl-seconds:number>] [--raw <json>]"
  },
  {
    "name": "list-contacts",
    "description": "List contact links for an agent in a project.",
    "usage": "list-contacts --project-key <project-key> --agent-name <agent-name> [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> [--raw <json>]"
  },
  {
    "name": "set-contact-policy",
    "description": "Set contact policy for an agent: open | auto | contacts_only | block_all.",
    "usage": "set-contact-policy --project-key <project-key> --agent-name <agent-name> --policy <policy> [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --policy <policy> [--raw <json>]"
  },
  {
    "name": "fetch-inbox",
    "description": "Retrieve recent messages for an agent without mutating read/ack state.\n\nFilters\n-------\n- `urgent_only`: only messages with importance in {high, urgent}\n- `since_ts`: ISO-8601 timestamp string; messages strictly newer than this are returned\n- `limit`: max number of messages (default 20)\n- `include_bodies`: include full Markdown bodies in the payloads\n\nUsage patterns\n--------------\n- Poll after each editing step in an agent loop to pick up coordination messages.\n- Use `since_ts` with the timestamp from your last poll for efficient incremental fetches.\n- Combine with `acknowledge_message` if `ack_required` is true.\n\nReturns\n-------\nlist[dict]\n    Each message includes: { id, subject, from, created_ts, importance, ack_required, kind, [body_md] }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"7\",\"method\":\"tools/call\",\"params\":{\"name\":\"fetch_inbox\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"since_ts\":\"2025-10-23T00:00:00+00:00\"\n}}}\n```",
    "usage": "fetch-inbox --project-key <project-key> --agent-name <agent-name> [--limit <limit:number>] [--urgent-only <urgent-only:true|false>] [--include-bodies <include-bodies:true|false>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> [--limit <limit:number>] [--urgent-only <urgent-only:true|false>] [--include-bodies <include-bodies:true|false>] [--raw <json>]"
  },
  {
    "name": "mark-message-read",
    "description": "Mark a specific message as read for the given agent.\n\nNotes\n-----\n- Read receipts are per-recipient; this only affects the specified agent.\n- This does not send an acknowledgement; use `acknowledge_message` for that.\n- Safe to call multiple times; later calls return the original timestamp.\n\nIdempotency\n-----------\n- If `mark_message_read` has already been called earlier for the same (agent, message),\n  the original timestamp is returned and no error is raised.\n\nReturns\n-------\ndict\n    { message_id, read: bool, read_at: iso8601 | null }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"8\",\"method\":\"tools/call\",\"params\":{\"name\":\"mark_message_read\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"message_id\":1234\n}}}\n```",
    "usage": "mark-message-read --project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]"
  },
  {
    "name": "acknowledge-message",
    "description": "Acknowledge a message addressed to an agent (and mark as read).\n\nBehavior\n--------\n- Sets both read_ts and ack_ts for the (agent, message) pairing\n- Safe to call multiple times; subsequent calls will return the prior timestamps\n\nIdempotency\n-----------\n- If acknowledgement already exists, the previous timestamps are preserved and returned.\n\nWhen to use\n-----------\n- Respond to messages with `ack_required=true` to signal explicit receipt.\n- Agents can treat an acknowledgement as a lightweight, non-textual reply.\n\nReturns\n-------\ndict\n    { message_id, acknowledged: bool, acknowledged_at: iso8601 | null, read_at: iso8601 | null }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"9\",\"method\":\"tools/call\",\"params\":{\"name\":\"acknowledge_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"message_id\":1234\n}}}\n```",
    "usage": "acknowledge-message --project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]"
  },
  {
    "name": "macro-start-session",
    "description": "Macro helper that boots a project session: ensure project, register agent,\noptionally file_reservation paths, and fetch the latest inbox snapshot.",
    "usage": "macro-start-session --human-key <human-key> --program <program> --model <model> [--task-description <task-description>] [--agent-name <agent-name>] [--raw <json>]",
    "flags": "--human-key <human-key> --program <program> --model <model> [--task-description <task-description>] [--agent-name <agent-name>] [--raw <json>]"
  },
  {
    "name": "macro-prepare-thread",
    "description": "Macro helper that aligns an agent with an existing thread by ensuring registration,\nsummarising the thread, and fetching recent inbox context.",
    "usage": "macro-prepare-thread --project-key <project-key> --thread-id <thread-id> --program <program> --model <model> [--agent-name <agent-name>] [--raw <json>]",
    "flags": "--project-key <project-key> --thread-id <thread-id> --program <program> --model <model> [--agent-name <agent-name>] [--raw <json>]"
  },
  {
    "name": "macro-file-reservation-cycle",
    "description": "Reserve a set of file paths and optionally release them at the end of the workflow.",
    "usage": "macro-file-reservation-cycle --project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]"
  },
  {
    "name": "macro-contact-handshake",
    "description": "Request contact permissions and optionally auto-approve plus send a welcome message.",
    "usage": "macro-contact-handshake --project-key <project-key> [--requester <requester>] [--target <target>] [--reason <reason>] [--ttl-seconds <ttl-seconds:number>] [--raw <json>]",
    "flags": "--project-key <project-key> [--requester <requester>] [--target <target>] [--reason <reason>] [--ttl-seconds <ttl-seconds:number>] [--raw <json>]"
  },
  {
    "name": "search-messages",
    "description": "Full-text search over subject and body for a project.\n\nTips\n----\n- SQLite FTS5 syntax supported: phrases (\"build plan\"), prefix (mig*), boolean (plan AND users)\n- Results are ordered by bm25 score (best matches first)\n- Limit defaults to 20; raise for broad queries\n\nQuery examples\n---------------\n- Phrase search: `\"build plan\"`\n- Prefix: `migrat*`\n- Boolean: `plan AND users`\n- Require urgent: `urgent AND deployment`\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nquery : str\n    FTS5 query string.\nlimit : int\n    Max results to return.\n\nReturns\n-------\nlist[dict]\n    Each entry: { id, subject, importance, ack_required, created_ts, thread_id, from }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"10\",\"method\":\"tools/call\",\"params\":{\"name\":\"search_messages\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"query\":\"\"build plan\" AND users\", \"limit\": 50\n}}}\n```",
    "usage": "search-messages --project-key <project-key> --query <query> [--limit <limit:number>] [--raw <json>]",
    "flags": "--project-key <project-key> --query <query> [--limit <limit:number>] [--raw <json>]"
  },
  {
    "name": "summarize-thread",
    "description": "Extract participants, key points, and action items for one or more threads.\n\nSingle-thread mode (thread_id is a single ID):\n- Returns detailed summary with optional example messages\n- Response: { thread_id, summary: {participants[], key_points[], action_items[]}, examples[] }\n\nMulti-thread mode (thread_id is comma-separated IDs like \"TKT-1,TKT-2,TKT-3\"):\n- Returns aggregate digest across all threads\n- Response: { threads: [{thread_id, summary}], aggregate: {top_mentions[], key_points[], action_items[]} }\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nthread_id : str\n    Single thread ID for detailed summary, OR comma-separated IDs for aggregate digest.\ninclude_examples : bool\n    If true (single-thread mode only), include up to 3 sample messages.\nllm_mode : bool\n    If true and LLM is enabled, refine the summary with AI.\nllm_model : Optional[str]\n    Override model name for the LLM call.\nper_thread_limit : int\n    Max messages to consider per thread (multi-thread mode).\n\nExamples\n--------\nSingle thread:\n```json\n{\"thread_id\": \"TKT-123\", \"include_examples\": true}\n```\n\nMultiple threads:\n```json\n{\"thread_id\": \"TKT-1,TKT-2,TKT-3\"}\n```",
    "usage": "summarize-thread --project-key <project-key> --thread-id <thread-id> [--include-examples <include-examples:true|false>] [--llm-mode <llm-mode:true|false>] [--llm-model <llm-model>] [--raw <json>]",
    "flags": "--project-key <project-key> --thread-id <thread-id> [--include-examples <include-examples:true|false>] [--llm-mode <llm-mode:true|false>] [--llm-model <llm-model>] [--raw <json>]"
  },
  {
    "name": "install-precommit-guard",
    "description": "",
    "usage": "install-precommit-guard --project-key <project-key> --code-repo-path <code-repo-path> [--raw <json>]",
    "flags": "--project-key <project-key> --code-repo-path <code-repo-path> [--raw <json>]"
  },
  {
    "name": "uninstall-precommit-guard",
    "description": "",
    "usage": "uninstall-precommit-guard --code-repo-path <code-repo-path> [--raw <json>]",
    "flags": "--code-repo-path <code-repo-path> [--raw <json>]"
  },
  {
    "name": "file-reservation-paths",
    "description": "Request advisory file reservations (leases) on project-relative paths/globs.\n\nSemantics\n---------\n- Conflicts are reported if an overlapping active exclusive reservation exists held by another agent\n- Glob matching is symmetric (`fnmatchcase(a,b)` or `fnmatchcase(b,a)`), including exact matches\n- When granted, a JSON artifact is written under `file_reservations/<sha1(path)>.json` and the DB is updated\n- TTL must be >= 60 seconds (enforced by the server settings/policy)\n\nDo / Don't\n----------\nDo:\n- Reserve files before starting edits to signal intent to other agents.\n- Use specific, minimal patterns (e.g., `app/api/*.py`) instead of broad globs.\n- Set a realistic TTL and renew with `renew_file_reservations` if you need more time.\n\nDon't:\n- Reserve the entire repository or very broad patterns (e.g., `**/*`) unless absolutely necessary.\n- Hold long-lived exclusive reservations when you are not actively editing.\n- Ignore conflicts; resolve them by coordinating with holders or waiting for expiry.\n\nParameters\n----------\nproject_key : str\nagent_name : str\npaths : list[str]\n    File paths or glob patterns relative to the project workspace (e.g., \"app/api/*.py\").\nttl_seconds : int\n    Time to live for the file_reservation; expired file_reservations are auto-released.\nexclusive : bool\n    If true, exclusive intent; otherwise shared/observe-only.\nreason : str\n    Optional explanation (helps humans reviewing Git artifacts).\n\nReturns\n-------\ndict\n    { granted: [{id, path_pattern, exclusive, reason, expires_ts}], conflicts: [{path, holders: [...]}] }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"12\",\"method\":\"tools/call\",\"params\":{\"name\":\"file_reservation_paths\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\",\"paths\":[\"app/api/*.py\"],\n  \"ttl_seconds\":7200,\"exclusive\":true,\"reason\":\"migrations\"\n}}}\n```",
    "usage": "file-reservation-paths --project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]"
  },
  {
    "name": "release-file-reservations",
    "description": "Release active file reservations held by an agent.\n\nBehavior\n--------\n- If both `paths` and `file_reservation_ids` are omitted, all active reservations for the agent are released\n- Otherwise, restricts release to matching ids and/or path patterns\n- JSON artifacts stay in Git for audit; DB records get `released_ts`\n\nReturns\n-------\ndict\n    { released: int, released_at: iso8601 }\n\nIdempotency\n-----------\n- Safe to call repeatedly. Releasing an already-released (or non-existent) reservation is a no-op.\n\nExamples\n--------\nRelease all active reservations for agent:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"13\",\"method\":\"tools/call\",\"params\":{\"name\":\"release_file_reservations\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\"\n}}}\n```\n\nRelease by ids:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"14\",\"method\":\"tools/call\",\"params\":{\"name\":\"release_file_reservations\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\",\"file_reservation_ids\":[101,102]\n}}}\n```",
    "usage": "release-file-reservations --project-key <project-key> --agent-name <agent-name> [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]"
  },
  {
    "name": "force-release-file-reservation",
    "description": "Force-release a stale file reservation held by another agent after inactivity heuristics.\n\nThe tool validates that the reservation appears abandoned (agent inactive beyond threshold and\nno recent mail/filesystem/git activity). When released, an optional notification is sent to the\nprevious holder summarizing the heuristics.",
    "usage": "force-release-file-reservation --project-key <project-key> --agent-name <agent-name> --file-reservation-id <file-reservation-id:number> [--notify-previous <notify-previous:true|false>] [--note <note>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> --file-reservation-id <file-reservation-id:number> [--notify-previous <notify-previous:true|false>] [--note <note>] [--raw <json>]"
  },
  {
    "name": "renew-file-reservations",
    "description": "Extend expiry for active file reservations held by an agent without reissuing them.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nagent_name : str\n    Agent identity who owns the reservations.\nextend_seconds : int\n    Seconds to extend from the later of now or current expiry (min 60s).\npaths : Optional[list[str]]\n    Restrict renewals to matching path patterns.\nfile_reservation_ids : Optional[list[int]]\n    Restrict renewals to matching reservation ids.\n\nReturns\n-------\ndict\n    { renewed: int, file_reservations: [{id, path_pattern, old_expires_ts, new_expires_ts}] }",
    "usage": "renew-file-reservations --project-key <project-key> --agent-name <agent-name> [--extend-seconds <extend-seconds:number>] [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]",
    "flags": "--project-key <project-key> --agent-name <agent-name> [--extend-seconds <extend-seconds:number>] [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-01-07T18:25:01.566Z",
  "generator": {
    "name": "mcporter",
    "version": "0.7.3"
  },
  "server": {
    "name": "agent-mail",
    "definition": {
      "name": "agent-mail",
      "description": "You are the MCP Agent Mail coordination server. Provide message routing, coordination tooling, and project context to cooperating agents.",
      "command": {
        "kind": "http",
        "url": "http://127.0.0.1:8765/mcp/"
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "{\"name\":\"agent-mail\",\"command\":\"http://127.0.0.1:8765/mcp/\"}",
    "runtime": "bun",
    "bundler": "bun",
    "outputPath": ".claude/toolboxes/agent-mail.ts",
    "bundle": ".claude/toolboxes/agent-mail.js",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "health-check": "function health_check(): object;",
  "ensure-project": "function ensure_project(human_key: string, identity_mode?: unknown): object;",
  "register-agent": "function register_agent(project_key: string, program: string, model: string, name?: unknown, task_description?: string): object;",
  "whois": "function whois(project_key: string, agent_name: string, include_recent_commits?: boolean, commit_limit?: number): object;",
  "create-agent-identity": "function create_agent_identity(project_key: string, program: string, model: string, name_hint?: unknown, task_description?: string): object;",
  "send-message": "function send_message(project_key: string, sender_name: string, to: string[], subject: string, body_md: string): object;",
  "reply-message": "function reply_message(project_key: string, message_id: number, sender_name: string, body_md: string, to?: unknown): object;",
  "request-contact": "function request_contact(project_key: string, from_agent: string, to_agent: string, to_project?: unknown, reason?: string): object;",
  "respond-contact": "function respond_contact(project_key: string, to_agent: string, from_agent: string, accept: boolean, ttl_seconds?: number): object;",
  "list-contacts": "function list_contacts(project_key: string, agent_name: string): object;",
  "set-contact-policy": "function set_contact_policy(project_key: string, agent_name: string, policy: string): object;",
  "fetch-inbox": "function fetch_inbox(project_key: string, agent_name: string, limit?: number, urgent_only?: boolean, include_bodies?: boolean): object;",
  "mark-message-read": "function mark_message_read(project_key: string, agent_name: string, message_id: number): object;",
  "acknowledge-message": "function acknowledge_message(project_key: string, agent_name: string, message_id: number): object;",
  "macro-start-session": "function macro_start_session(human_key: string, program: string, model: string, task_description?: string, agent_name?: unknown): object;",
  "macro-prepare-thread": "function macro_prepare_thread(project_key: string, thread_id: string, program: string, model: string, agent_name?: unknown): object;",
  "macro-file-reservation-cycle": "function macro_file_reservation_cycle(project_key: string, agent_name: string, paths: string[], ttl_seconds?: number, exclusive?: boolean): object;",
  "macro-contact-handshake": "function macro_contact_handshake(project_key: string, requester?: unknown, target?: unknown, reason?: string, ttl_seconds?: number): object;",
  "search-messages": "function search_messages(project_key: string, query: string, limit?: number);",
  "summarize-thread": "function summarize_thread(project_key: string, thread_id: string, include_examples?: boolean, llm_mode?: boolean, llm_model?: unknown): object;",
  "install-precommit-guard": "function install_precommit_guard(project_key: string, code_repo_path: string): object;",
  "uninstall-precommit-guard": "function uninstall_precommit_guard(code_repo_path: string): object;",
  "file-reservation-paths": "function file_reservation_paths(project_key: string, agent_name: string, paths: string[], ttl_seconds?: number, exclusive?: boolean): object;",
  "release-file-reservations": "function release_file_reservations(project_key: string, agent_name: string, paths?: unknown, file_reservation_ids?: unknown): object;",
  "force-release-file-reservation": "function force_release_file_reservation(project_key: string, agent_name: string, file_reservation_id: number, notify_previous?: boolean, note?: string): object;",
  "renew-file-reservations": "function renew_file_reservations(project_key: string, agent_name: string, extend_seconds?: number, paths?: unknown, file_reservation_ids?: unknown): object;"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("health-check")
	.summary("health-check [--raw <json>]")
	.description("Return basic readiness information for the Agent Mail server.")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("health_check")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.healthCheck as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.health_check()");

program
	.command("ensure-project")
	.summary("ensure-project --human-key <human-key> [--identity-mode <identity-mode>] [--raw <json>]")
	.description("Idempotently create or ensure a project exists for the given human key.\n\nWhen to use\n-----------\n- First call in a workflow targeting a new repo/path identifier.\n- As a guard before registering agents or sending messages.\n\nHow it works\n------------\n- Validates that `human_key` is an absolute directory path (the agent's working directory).\n- Computes a stable slug from `human_key` (lowercased, safe characters) so\n  multiple agents can refer to the same project consistently.\n- Ensures DB row exists and that the on-disk archive is initialized\n  (e.g., `messages/`, `agents/`, `file_reservations/` directories).\n\nCRITICAL: Project Identity Rules\n---------------------------------\n- The `human_key` MUST be the absolute path to the agent's working directory\n- Two agents working in the SAME directory path are working on the SAME project\n- Example: Both agents in /data/projects/smartedgar_mcp → SAME project\n- Sibling projects are DIFFERENT directories (e.g., /data/projects/smartedgar_mcp\n  vs /data/projects/smartedgar_mcp_frontend)\n\nParameters\n----------\nhuman_key : str\n    The absolute path to the agent's working directory (e.g., \"/data/projects/backend\").\n    This MUST be an absolute path, not a relative path or arbitrary slug.\n    This is the canonical identifier for the project - all agents working in this\n    directory will share the same project identity.\n\nReturns\n-------\ndict\n    Minimal project descriptor: { id, slug, human_key, created_at }.\n\nExamples\n--------\nJSON-RPC:\n```json\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"2\",\n  \"method\": \"tools/call\",\n  \"params\": {\"name\": \"ensure_project\", \"arguments\": {\"human_key\": \"/data/projects/backend\"}}\n}\n```\n\nCommon mistakes\n---------------\n- Passing a relative path (e.g., \"./backend\") instead of an absolute path\n- Using arbitrary slugs instead of the actual working directory path\n- Creating separate projects for the same directory with different slugs\n\nIdempotency\n-----------\n- Safe to call multiple times. If the project already exists, the existing\n  record is returned and the archive is ensured on disk (no destructive changes).")
	.usage("--human-key <human-key> [--identity-mode <identity-mode>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--human-key <human-key>", "Set human_key.")
	.option("--identity-mode <identity-mode>", "Set identity_mode. (default: null; example: null)")
	
	.alias("ensure_project")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.humanKey !== undefined) args.human_key = cmdOpts.humanKey;
		if (cmdOpts.identityMode !== undefined) args.identity_mode = cmdOpts.identityMode;
			const call = (proxy.ensureProject as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.ensure_project(human_key: \"value\", identity_mode:, ...)");

program
	.command("register-agent")
	.summary("register-agent --project-key <project-key> --program <program> --model <model> [--name <name>] [--task-description <task-description>] [--raw <json>]")
	.description("Create or update an agent identity within a project and persist its profile to Git.\n\nWhen to use\n-----------\n- At the start of a coding session by any automated agent.\n- To update an existing agent's program/model/task metadata and bump last_active.\n\nSemantics\n---------\n- If `name` is omitted, a random adjective+noun name is auto-generated.\n- Reusing the same `name` updates the profile (program/model/task) and\n  refreshes `last_active_ts`.\n- A `profile.json` file is written under `agents/<Name>/` in the project archive.\n\nCRITICAL: Agent Naming Rules\n-----------------------------\n- Agent names MUST be randomly generated adjective+noun combinations\n- Examples: \"GreenLake\", \"BlueDog\", \"RedStone\", \"PurpleBear\"\n- Names should be unique, easy to remember, and NOT descriptive\n- INVALID examples: \"BackendHarmonizer\", \"DatabaseMigrator\", \"UIRefactorer\"\n- The whole point: names should be memorable identifiers, not role descriptions\n- Best practice: Omit the `name` parameter to auto-generate a valid name\n\nParameters\n----------\nproject_key : str\n    The same human key you passed to `ensure_project` (or equivalent identifier).\nprogram : str\n    The agent program (e.g., \"codex-cli\", \"claude-code\").\nmodel : str\n    The underlying model (e.g., \"gpt5-codex\", \"opus-4.1\").\nname : Optional[str]\n    MUST be a valid adjective+noun combination if provided (e.g., \"BlueLake\").\n    If omitted, a random valid name is auto-generated (RECOMMENDED).\n    Names are unique per project; passing the same name updates the profile.\ntask_description : str\n    Short description of current focus (shows up in directory listings).\n\nReturns\n-------\ndict\n    { id, name, program, model, task_description, inception_ts, last_active_ts, project_id }\n\nExamples\n--------\nRegister with auto-generated name (RECOMMENDED):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"3\",\"method\":\"tools/call\",\"params\":{\"name\":\"register_agent\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"codex-cli\",\"model\":\"gpt5-codex\",\"task_description\":\"Auth refactor\"\n}}}\n```\n\nRegister with explicit valid name:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"4\",\"method\":\"tools/call\",\"params\":{\"name\":\"register_agent\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"claude-code\",\"model\":\"opus-4.1\",\"name\":\"BlueLake\",\"task_description\":\"Navbar redesign\"\n}}}\n```\n\nPitfalls\n--------\n- Names MUST match the adjective+noun format or an error will be raised\n- Names are case-insensitive unique. If you see \"already in use\", pick another or omit `name`.\n- Use the same `project_key` consistently across cooperating agents.")
	.usage("--project-key <project-key> --program <program> --model <model> [--name <name>] [--task-description <task-description>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--program <program>", "Set program.")
	.requiredOption("--model <model>", "Set model.")
	.option("--name <name>", "Set name. (default: null; example: null)")
	.option("--task-description <task-description>", "Set task_description. (default: )")
	.option("--attachments-policy <attachments-policy>", "Set attachments_policy. (default: auto; example: auto)")
	
	.alias("register_agent")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
		if (cmdOpts.attachmentsPolicy !== undefined) args.attachments_policy = cmdOpts.attachmentsPolicy;
			const call = (proxy.registerAgent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.register_agent(project_key: \"value\", program: \"va, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): attachments_policy" + '\n');

program
	.command("whois")
	.summary("whois --project-key <project-key> --agent-name <agent-name> [--include-recent-commits <include-recent-commits:true|false>] [--commit-limit <commit-limit:number>] [--raw <json>]")
	.description("Return enriched profile details for an agent, optionally including recent archive commits.\n\nDiscovery\n---------\nTo discover available agent names, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nagent_name : str\n    Agent name to look up (use resource://agents/{project_key} to discover names).\ninclude_recent_commits : bool\n    If true, include latest commits touching the project archive authored by the configured git author.\ncommit_limit : int\n    Maximum number of recent commits to include.\n\nReturns\n-------\ndict\n    Agent profile augmented with { recent_commits: [{hexsha, summary, authored_ts}] } when requested.")
	.usage("--project-key <project-key> --agent-name <agent-name> [--include-recent-commits <include-recent-commits:true|false>] [--commit-limit <commit-limit:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.option("--include-recent-commits <include-recent-commits:true|false>", "Set include_recent_commits. (default: true; example: true)", (value) => value !== 'false')
	.option("--commit-limit <commit-limit:number>", "Set commit_limit. (default: 5; example: 5)", (value) => parseFloat(value))
	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.includeRecentCommits !== undefined) args.include_recent_commits = cmdOpts.includeRecentCommits;
		if (cmdOpts.commitLimit !== undefined) args.commit_limit = cmdOpts.commitLimit;
			const call = (proxy.whois as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.whois(project_key: \"value\", agent_name: \"value\", ...)");

program
	.command("create-agent-identity")
	.summary("create-agent-identity --project-key <project-key> --program <program> --model <model> [--name-hint <name-hint>] [--task-description <task-description>] [--raw <json>]")
	.description("Create a new, unique agent identity and persist its profile to Git.\n\nHow this differs from `register_agent`\n--------------------------------------\n- Always creates a new identity with a fresh unique name (never updates an existing one).\n- `name_hint`, if provided, MUST be a valid adjective+noun combination and must be available,\n  otherwise an error is raised. Without a hint, a random adjective+noun name is generated.\n\nCRITICAL: Agent Naming Rules\n-----------------------------\n- Agent names MUST be randomly generated adjective+noun combinations\n- Examples: \"GreenCastle\", \"BlueLake\", \"RedStone\", \"PurpleBear\"\n- Names should be unique, easy to remember, and NOT descriptive\n- INVALID examples: \"BackendHarmonizer\", \"DatabaseMigrator\", \"UIRefactorer\"\n- Best practice: Omit `name_hint` to auto-generate a valid name (RECOMMENDED)\n\nWhen to use\n-----------\n- Spawning a brand new worker agent that should not overwrite an existing profile.\n- Temporary task-specific identities (e.g., short-lived refactor assistants).\n\nReturns\n-------\ndict\n    { id, name, program, model, task_description, inception_ts, last_active_ts, project_id }\n\nExamples\n--------\nAuto-generate name (RECOMMENDED):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"c2\",\"method\":\"tools/call\",\"params\":{\"name\":\"create_agent_identity\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"claude-code\",\"model\":\"opus-4.1\"\n}}}\n```\n\nWith valid name hint:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"c1\",\"method\":\"tools/call\",\"params\":{\"name\":\"create_agent_identity\",\"arguments\":{\n  \"project_key\":\"/data/projects/backend\",\"program\":\"codex-cli\",\"model\":\"gpt5-codex\",\"name_hint\":\"GreenCastle\",\n  \"task_description\":\"DB migration spike\"\n}}}\n```")
	.usage("--project-key <project-key> --program <program> --model <model> [--name-hint <name-hint>] [--task-description <task-description>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--program <program>", "Set program.")
	.requiredOption("--model <model>", "Set model.")
	.option("--name-hint <name-hint>", "Set name_hint. (default: null; example: null)")
	.option("--task-description <task-description>", "Set task_description. (default: )")
	.option("--attachments-policy <attachments-policy>", "Set attachments_policy. (default: auto; example: auto)")
	
	.alias("create_agent_identity")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.nameHint !== undefined) args.name_hint = cmdOpts.nameHint;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
		if (cmdOpts.attachmentsPolicy !== undefined) args.attachments_policy = cmdOpts.attachmentsPolicy;
			const call = (proxy.createAgentIdentity as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.create_agent_identity(project_key: \"value\", progr, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): attachments_policy" + '\n');

program
	.command("send-message")
	.summary("send-message --project-key <project-key> --sender-name <sender-name> --to <to:value1,value2> --subject <subject> --body-md <body-md> [--raw <json>]")
	.description("Send a Markdown message to one or more recipients and persist canonical and mailbox copies to Git.\n\nDiscovery\n---------\nTo discover available agent names for recipients, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nWhat this does\n--------------\n- Stores message (and recipients) in the database; updates sender's activity\n- Writes a canonical `.md` under `messages/YYYY/MM/`\n- Writes sender outbox and per-recipient inbox copies\n- Optionally converts referenced images to WebP and embeds small images inline\n- Supports explicit attachments via `attachment_paths` in addition to inline references\n\nParameters\n----------\nproject_key : str\n    Project identifier (same used with `ensure_project`/`register_agent`).\nsender_name : str\n    Must match an agent registered in the project.\nto : list[str]\n    Primary recipients (agent names). At least one of to/cc/bcc must be non-empty.\nsubject : str\n    Short subject line that will be visible in inbox/outbox and search results.\nbody_md : str\n    GitHub-Flavored Markdown body. Image references can be file paths or data URIs.\ncc, bcc : Optional[list[str]]\n    Additional recipients by name.\nattachment_paths : Optional[list[str]]\n    Extra file paths to include as attachments; will be converted to WebP and stored.\nconvert_images : Optional[bool]\n    Overrides server default for image conversion/inlining. If None, server settings apply.\nimportance : str\n    One of {\"low\",\"normal\",\"high\",\"urgent\"} (free form tolerated; used by filters).\nack_required : bool\n    If true, recipients should call `acknowledge_message` after reading.\nthread_id : Optional[str]\n    If provided, message will be associated with an existing thread.\n\nReturns\n-------\ndict\n    {\n      \"deliveries\": [ { \"project\": str, \"payload\": { ... message payload ... } } ],\n      \"count\": int\n    }\n\nEdge cases\n----------\n- If no recipients are given, the call fails.\n- Unknown recipient names fail fast; register them first.\n- Non-absolute attachment paths are resolved relative to the project archive root.\n\nDo / Don't\n----------\nDo:\n- Keep subjects concise and specific (aim for ≤ 80 characters).\n- Use `thread_id` (or `reply_message`) to keep related discussion in a single thread.\n- Address only relevant recipients; use CC/BCC sparingly and intentionally.\n- Prefer Markdown links; attach images only when they materially aid understanding. The server\n  auto-converts images to WebP and may inline small images depending on policy.\n\nDon't:\n- Send large, repeated binaries—reuse prior attachments via `attachment_paths` when possible.\n- Change topics mid-thread—start a new thread for a new subject.\n- Broadcast to \"all\" agents unnecessarily—target just the agents who need to act.\n\nExamples\n--------\n1) Simple message:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"5\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Plan for /api/users\",\"body_md\":\"See below.\"\n}}}\n```\n\n2) Inline image (auto-convert to WebP and inline if small):\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6a\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Diagram\",\"body_md\":\"![diagram](docs/flow.png)\",\"convert_images\":true\n}}}\n```\n\n3) Explicit attachments:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6b\",\"method\":\"tools/call\",\"params\":{\"name\":\"send_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"sender_name\":\"GreenCastle\",\"to\":[\"BlueLake\"],\n  \"subject\":\"Screenshots\",\"body_md\":\"Please review.\",\"attachment_paths\":[\"shots/a.png\",\"shots/b.png\"]\n}}}\n```")
	.usage("--project-key <project-key> --sender-name <sender-name> --to <to:value1,value2> --subject <subject> --body-md <body-md> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--sender-name <sender-name>", "Set sender_name.")
	.requiredOption("--to <to:value1,value2>", "Set to. (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.requiredOption("--subject <subject>", "Set subject.")
	.requiredOption("--body-md <body-md>", "Set body_md.")
	.option("--cc <cc>", "Set cc. (default: null; example: null)")
	.option("--bcc <bcc>", "Set bcc. (default: null; example: null)")
	.option("--attachment-paths <attachment-paths>", "Set attachment_paths. (default: null; example: null)")
	.option("--convert-images <convert-images>", "Set convert_images. (default: null; example: null)")
	.option("--importance <importance>", "Set importance. (default: normal; example: normal)")
	.option("--ack-required <ack-required:true|false>", "Set ack_required. (default: false; example: false)", (value) => value !== 'false')
	.option("--thread-id <thread-id>", "Set thread_id. (default: null; example: null)")
	.option("--auto-contact-if-blocked <auto-contact-if-blocked:true|false>", "Set auto_contact_if_blocked. (default: false; example: false)", (value) => value !== 'false')
	
	.alias("send_message")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.senderName !== undefined) args.sender_name = cmdOpts.senderName;
		if (cmdOpts.to !== undefined) args.to = cmdOpts.to;
		if (cmdOpts.subject !== undefined) args.subject = cmdOpts.subject;
		if (cmdOpts.bodyMd !== undefined) args.body_md = cmdOpts.bodyMd;
		if (cmdOpts.cc !== undefined) args.cc = cmdOpts.cc;
		if (cmdOpts.bcc !== undefined) args.bcc = cmdOpts.bcc;
		if (cmdOpts.attachmentPaths !== undefined) args.attachment_paths = cmdOpts.attachmentPaths;
		if (cmdOpts.convertImages !== undefined) args.convert_images = cmdOpts.convertImages;
		if (cmdOpts.importance !== undefined) args.importance = cmdOpts.importance;
		if (cmdOpts.ackRequired !== undefined) args.ack_required = cmdOpts.ackRequired;
		if (cmdOpts.threadId !== undefined) args.thread_id = cmdOpts.threadId;
		if (cmdOpts.autoContactIfBlocked !== undefined) args.auto_contact_if_blocked = cmdOpts.autoContactIfBlocked;
			const call = (proxy.sendMessage as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.send_message(project_key: \"value\", sender_name: \", ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (8): cc, bcc, attachment_paths, convert_images, importance, ..." + '\n');

program
	.command("reply-message")
	.summary("reply-message --project-key <project-key> --message-id <message-id:number> --sender-name <sender-name> --body-md <body-md> [--to <to>] [--raw <json>]")
	.description("Reply to an existing message, preserving or establishing a thread.\n\nBehavior\n--------\n- Inherits original `importance` and `ack_required` flags\n- `thread_id` is taken from the original message if present; otherwise, the original id is used\n- Subject is prefixed with `subject_prefix` if not already present\n- Defaults `to` to the original sender if not explicitly provided\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nmessage_id : int\n    The id of the message you are replying to.\nsender_name : str\n    Your agent name (must be registered in the project).\nbody_md : str\n    Reply body in Markdown.\nto, cc, bcc : Optional[list[str]]\n    Recipients by agent name. If omitted, `to` defaults to original sender.\nsubject_prefix : str\n    Prefix to apply (default \"Re:\"). Case-insensitive idempotent.\n\nDo / Don't\n----------\nDo:\n- Keep the subject focused; avoid topic drift within a thread.\n- Reply to the original sender unless new stakeholders are strictly required.\n- Preserve importance/ack flags from the original unless there is a clear reason to change.\n- Use CC for FYI only; BCC sparingly and with intention.\n\nDon't:\n- Change `thread_id` when continuing the same discussion.\n- Escalate to many recipients; prefer targeted replies and start a new thread for new topics.\n- Attach large binaries in replies unless essential; reference prior attachments where possible.\n\nReturns\n-------\ndict\n    Message payload including `thread_id` and `reply_to`.\n\nExamples\n--------\nMinimal reply to original sender:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6\",\"method\":\"tools/call\",\"params\":{\"name\":\"reply_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"message_id\":1234,\"sender_name\":\"BlueLake\",\n  \"body_md\":\"Questions about the migration plan...\"\n}}}\n```\n\nReply with explicit recipients and CC:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"6c\",\"method\":\"tools/call\",\"params\":{\"name\":\"reply_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"message_id\":1234,\"sender_name\":\"BlueLake\",\n  \"body_md\":\"Looping ops.\",\"to\":[\"GreenCastle\"],\"cc\":[\"RedCat\"],\"subject_prefix\":\"RE:\"\n}}}\n```")
	.usage("--project-key <project-key> --message-id <message-id:number> --sender-name <sender-name> --body-md <body-md> [--to <to>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--message-id <message-id:number>", "Set message_id. (example: 1)", (value) => parseFloat(value))
	.requiredOption("--sender-name <sender-name>", "Set sender_name.")
	.requiredOption("--body-md <body-md>", "Set body_md.")
	.option("--to <to>", "Set to. (default: null; example: null)")
	.option("--cc <cc>", "Set cc. (default: null; example: null)")
	.option("--bcc <bcc>", "Set bcc. (default: null; example: null)")
	.option("--subject-prefix <subject-prefix>", "Set subject_prefix. (default: Re:; example: Re:)")
	
	.alias("reply_message")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.messageId !== undefined) args.message_id = cmdOpts.messageId;
		if (cmdOpts.senderName !== undefined) args.sender_name = cmdOpts.senderName;
		if (cmdOpts.bodyMd !== undefined) args.body_md = cmdOpts.bodyMd;
		if (cmdOpts.to !== undefined) args.to = cmdOpts.to;
		if (cmdOpts.cc !== undefined) args.cc = cmdOpts.cc;
		if (cmdOpts.bcc !== undefined) args.bcc = cmdOpts.bcc;
		if (cmdOpts.subjectPrefix !== undefined) args.subject_prefix = cmdOpts.subjectPrefix;
			const call = (proxy.replyMessage as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.reply_message(project_key: \"value\", message_id: 1, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (3): cc, bcc, subject_prefix" + '\n');

program
	.command("request-contact")
	.summary("request-contact --project-key <project-key> --from-agent <from-agent> --to-agent <to-agent> [--to-project <to-project>] [--reason <reason>] [--raw <json>]")
	.description("Request contact approval to message another agent.\n\nCreates (or refreshes) a pending AgentLink and sends a small ack_required intro message.\n\nDiscovery\n---------\nTo discover available agent names, use: resource://agents/{project_key}\nAgent names are NOT the same as program names or user names.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nfrom_agent : str\n    Your agent name (must be registered in the project).\nto_agent : str\n    Target agent name (use resource://agents/{project_key} to discover names).\nto_project : Optional[str]\n    Target project if different from your project (cross-project coordination).\nreason : str\n    Optional explanation for the contact request.\nttl_seconds : int\n    Time to live for the contact approval request (default: 7 days).")
	.usage("--project-key <project-key> --from-agent <from-agent> --to-agent <to-agent> [--to-project <to-project>] [--reason <reason>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--from-agent <from-agent>", "Set from_agent.")
	.requiredOption("--to-agent <to-agent>", "Set to_agent.")
	.option("--to-project <to-project>", "Set to_project. (default: null; example: null)")
	.option("--reason <reason>", "Set reason. (default: )")
	.option("--ttl-seconds <ttl-seconds:number>", "Set ttl_seconds. (default: 604800; example: 604800)", (value) => parseFloat(value))
	.option("--register-if-missing <register-if-missing:true|false>", "Set register_if_missing. (default: true; example: true)", (value) => value !== 'false')
	.option("--program <program>", "Set program. (default: null; example: null)")
	.option("--model <model>", "Set model. (default: null; example: null)")
	.option("--task-description <task-description>", "Set task_description. (default: null; example: null)")
	
	.alias("request_contact")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.fromAgent !== undefined) args.from_agent = cmdOpts.fromAgent;
		if (cmdOpts.toAgent !== undefined) args.to_agent = cmdOpts.toAgent;
		if (cmdOpts.toProject !== undefined) args.to_project = cmdOpts.toProject;
		if (cmdOpts.reason !== undefined) args.reason = cmdOpts.reason;
		if (cmdOpts.ttlSeconds !== undefined) args.ttl_seconds = cmdOpts.ttlSeconds;
		if (cmdOpts.registerIfMissing !== undefined) args.register_if_missing = cmdOpts.registerIfMissing;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
			const call = (proxy.requestContact as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.request_contact(project_key: \"value\", from_agent:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (5): ttl_seconds, register_if_missing, program, model, task_description" + '\n');

program
	.command("respond-contact")
	.summary("respond-contact --project-key <project-key> --to-agent <to-agent> --from-agent <from-agent> --accept <accept:true|false> [--ttl-seconds <ttl-seconds:number>] [--raw <json>]")
	.description("Approve or deny a contact request.")
	.usage("--project-key <project-key> --to-agent <to-agent> --from-agent <from-agent> --accept <accept:true|false> [--ttl-seconds <ttl-seconds:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--to-agent <to-agent>", "Set to_agent.")
	.requiredOption("--from-agent <from-agent>", "Set from_agent.")
	.requiredOption("--accept <accept:true|false>", "Set accept. (example: true)", (value) => value !== 'false')
	.option("--ttl-seconds <ttl-seconds:number>", "Set ttl_seconds. (default: 2592000; example: 2592000)", (value) => parseFloat(value))
	.option("--from-project <from-project>", "Set from_project. (default: null; example: null)")
	
	.alias("respond_contact")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.toAgent !== undefined) args.to_agent = cmdOpts.toAgent;
		if (cmdOpts.fromAgent !== undefined) args.from_agent = cmdOpts.fromAgent;
		if (cmdOpts.accept !== undefined) args.accept = cmdOpts.accept;
		if (cmdOpts.ttlSeconds !== undefined) args.ttl_seconds = cmdOpts.ttlSeconds;
		if (cmdOpts.fromProject !== undefined) args.from_project = cmdOpts.fromProject;
			const call = (proxy.respondContact as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.respond_contact(project_key: \"value\", to_agent: \", ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): from_project" + '\n');

program
	.command("list-contacts")
	.summary("list-contacts --project-key <project-key> --agent-name <agent-name> [--raw <json>]")
	.description("List contact links for an agent in a project.")
	.usage("--project-key <project-key> --agent-name <agent-name> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	
	.alias("list_contacts")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
			const call = (proxy.listContacts as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.list_contacts(project_key: \"value\", agent_name: \", ...)");

program
	.command("set-contact-policy")
	.summary("set-contact-policy --project-key <project-key> --agent-name <agent-name> --policy <policy> [--raw <json>]")
	.description("Set contact policy for an agent: open | auto | contacts_only | block_all.")
	.usage("--project-key <project-key> --agent-name <agent-name> --policy <policy> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--policy <policy>", "Set policy.")
	
	.alias("set_contact_policy")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.policy !== undefined) args.policy = cmdOpts.policy;
			const call = (proxy.setContactPolicy as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.set_contact_policy(project_key: \"value\", agent_na, ...)");

program
	.command("fetch-inbox")
	.summary("fetch-inbox --project-key <project-key> --agent-name <agent-name> [--limit <limit:number>] [--urgent-only <urgent-only:true|false>] [--include-bodies <include-bodies:true|false>] [--raw <json>]")
	.description("Retrieve recent messages for an agent without mutating read/ack state.\n\nFilters\n-------\n- `urgent_only`: only messages with importance in {high, urgent}\n- `since_ts`: ISO-8601 timestamp string; messages strictly newer than this are returned\n- `limit`: max number of messages (default 20)\n- `include_bodies`: include full Markdown bodies in the payloads\n\nUsage patterns\n--------------\n- Poll after each editing step in an agent loop to pick up coordination messages.\n- Use `since_ts` with the timestamp from your last poll for efficient incremental fetches.\n- Combine with `acknowledge_message` if `ack_required` is true.\n\nReturns\n-------\nlist[dict]\n    Each message includes: { id, subject, from, created_ts, importance, ack_required, kind, [body_md] }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"7\",\"method\":\"tools/call\",\"params\":{\"name\":\"fetch_inbox\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"since_ts\":\"2025-10-23T00:00:00+00:00\"\n}}}\n```")
	.usage("--project-key <project-key> --agent-name <agent-name> [--limit <limit:number>] [--urgent-only <urgent-only:true|false>] [--include-bodies <include-bodies:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.option("--limit <limit:number>", "Set limit. (default: 20; example: 20)", (value) => parseFloat(value))
	.option("--urgent-only <urgent-only:true|false>", "Set urgent_only. (default: false; example: false)", (value) => value !== 'false')
	.option("--include-bodies <include-bodies:true|false>", "Set include_bodies. (default: false; example: false)", (value) => value !== 'false')
	.option("--since-ts <since-ts>", "Set since_ts. (default: null; example: null)")
	
	.alias("fetch_inbox")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
		if (cmdOpts.urgentOnly !== undefined) args.urgent_only = cmdOpts.urgentOnly;
		if (cmdOpts.includeBodies !== undefined) args.include_bodies = cmdOpts.includeBodies;
		if (cmdOpts.sinceTs !== undefined) args.since_ts = cmdOpts.sinceTs;
			const call = (proxy.fetchInbox as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.fetch_inbox(project_key: \"value\", agent_name: \"va, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): since_ts" + '\n');

program
	.command("mark-message-read")
	.summary("mark-message-read --project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]")
	.description("Mark a specific message as read for the given agent.\n\nNotes\n-----\n- Read receipts are per-recipient; this only affects the specified agent.\n- This does not send an acknowledgement; use `acknowledge_message` for that.\n- Safe to call multiple times; later calls return the original timestamp.\n\nIdempotency\n-----------\n- If `mark_message_read` has already been called earlier for the same (agent, message),\n  the original timestamp is returned and no error is raised.\n\nReturns\n-------\ndict\n    { message_id, read: bool, read_at: iso8601 | null }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"8\",\"method\":\"tools/call\",\"params\":{\"name\":\"mark_message_read\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"message_id\":1234\n}}}\n```")
	.usage("--project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--message-id <message-id:number>", "Set message_id. (example: 1)", (value) => parseFloat(value))
	
	.alias("mark_message_read")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.messageId !== undefined) args.message_id = cmdOpts.messageId;
			const call = (proxy.markMessageRead as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.mark_message_read(project_key: \"value\", agent_nam, ...)");

program
	.command("acknowledge-message")
	.summary("acknowledge-message --project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]")
	.description("Acknowledge a message addressed to an agent (and mark as read).\n\nBehavior\n--------\n- Sets both read_ts and ack_ts for the (agent, message) pairing\n- Safe to call multiple times; subsequent calls will return the prior timestamps\n\nIdempotency\n-----------\n- If acknowledgement already exists, the previous timestamps are preserved and returned.\n\nWhen to use\n-----------\n- Respond to messages with `ack_required=true` to signal explicit receipt.\n- Agents can treat an acknowledgement as a lightweight, non-textual reply.\n\nReturns\n-------\ndict\n    { message_id, acknowledged: bool, acknowledged_at: iso8601 | null, read_at: iso8601 | null }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"9\",\"method\":\"tools/call\",\"params\":{\"name\":\"acknowledge_message\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"BlueLake\",\"message_id\":1234\n}}}\n```")
	.usage("--project-key <project-key> --agent-name <agent-name> --message-id <message-id:number> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--message-id <message-id:number>", "Set message_id. (example: 1)", (value) => parseFloat(value))
	
	.alias("acknowledge_message")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.messageId !== undefined) args.message_id = cmdOpts.messageId;
			const call = (proxy.acknowledgeMessage as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.acknowledge_message(project_key: \"value\", agent_n, ...)");

program
	.command("macro-start-session")
	.summary("macro-start-session --human-key <human-key> --program <program> --model <model> [--task-description <task-description>] [--agent-name <agent-name>] [--raw <json>]")
	.description("Macro helper that boots a project session: ensure project, register agent,\noptionally file_reservation paths, and fetch the latest inbox snapshot.")
	.usage("--human-key <human-key> --program <program> --model <model> [--task-description <task-description>] [--agent-name <agent-name>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--human-key <human-key>", "Set human_key.")
	.requiredOption("--program <program>", "Set program.")
	.requiredOption("--model <model>", "Set model.")
	.option("--task-description <task-description>", "Set task_description. (default: )")
	.option("--agent-name <agent-name>", "Set agent_name. (default: null; example: null)")
	.option("--file-reservation-paths <file-reservation-paths>", "Set file_reservation_paths. (default: null; example: null)")
	.option("--file-reservation-reason <file-reservation-reason>", "Set file_reservation_reason. (default: macro-session; example: macro-session)")
	.option("--file-reservation-ttl-seconds <file-reservation-ttl-seconds:number>", "Set file_reservation_ttl_seconds. (default: 3600; example: 3600)", (value) => parseFloat(value))
	.option("--inbox-limit <inbox-limit:number>", "Set inbox_limit. (default: 10; example: 10)", (value) => parseFloat(value))
	
	.alias("macro_start_session")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.humanKey !== undefined) args.human_key = cmdOpts.humanKey;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.fileReservationPaths !== undefined) args.file_reservation_paths = cmdOpts.fileReservationPaths;
		if (cmdOpts.fileReservationReason !== undefined) args.file_reservation_reason = cmdOpts.fileReservationReason;
		if (cmdOpts.fileReservationTtlSeconds !== undefined) args.file_reservation_ttl_seconds = cmdOpts.fileReservationTtlSeconds;
		if (cmdOpts.inboxLimit !== undefined) args.inbox_limit = cmdOpts.inboxLimit;
			const call = (proxy.macroStartSession as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.macro_start_session(human_key: \"value\", program:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (4): file_reservation_paths, file_reservation_reason, file_reservation_ttl_seconds, inbox_limit" + '\n');

program
	.command("macro-prepare-thread")
	.summary("macro-prepare-thread --project-key <project-key> --thread-id <thread-id> --program <program> --model <model> [--agent-name <agent-name>] [--raw <json>]")
	.description("Macro helper that aligns an agent with an existing thread by ensuring registration,\nsummarising the thread, and fetching recent inbox context.")
	.usage("--project-key <project-key> --thread-id <thread-id> --program <program> --model <model> [--agent-name <agent-name>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--thread-id <thread-id>", "Set thread_id. (example: example-id)")
	.requiredOption("--program <program>", "Set program.")
	.requiredOption("--model <model>", "Set model.")
	.option("--agent-name <agent-name>", "Set agent_name. (default: null; example: null)")
	.option("--task-description <task-description>", "Set task_description. (default: )")
	.option("--register-if-missing <register-if-missing:true|false>", "Set register_if_missing. (default: true; example: true)", (value) => value !== 'false')
	.option("--include-examples <include-examples:true|false>", "Set include_examples. (default: true; example: true)", (value) => value !== 'false')
	.option("--inbox-limit <inbox-limit:number>", "Set inbox_limit. (default: 10; example: 10)", (value) => parseFloat(value))
	.option("--include-inbox-bodies <include-inbox-bodies:true|false>", "Set include_inbox_bodies. (default: false; example: false)", (value) => value !== 'false')
	.option("--llm-mode <llm-mode:true|false>", "Set llm_mode. (default: true; example: true)", (value) => value !== 'false')
	.option("--llm-model <llm-model>", "Set llm_model. (default: null; example: null)")
	
	.alias("macro_prepare_thread")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.threadId !== undefined) args.thread_id = cmdOpts.threadId;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
		if (cmdOpts.registerIfMissing !== undefined) args.register_if_missing = cmdOpts.registerIfMissing;
		if (cmdOpts.includeExamples !== undefined) args.include_examples = cmdOpts.includeExamples;
		if (cmdOpts.inboxLimit !== undefined) args.inbox_limit = cmdOpts.inboxLimit;
		if (cmdOpts.includeInboxBodies !== undefined) args.include_inbox_bodies = cmdOpts.includeInboxBodies;
		if (cmdOpts.llmMode !== undefined) args.llm_mode = cmdOpts.llmMode;
		if (cmdOpts.llmModel !== undefined) args.llm_model = cmdOpts.llmModel;
			const call = (proxy.macroPrepareThread as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.macro_prepare_thread(project_key: \"value\", thread, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (7): task_description, register_if_missing, include_examples, inbox_limit, include_inbox_bodies, ..." + '\n');

program
	.command("macro-file-reservation-cycle")
	.summary("macro-file-reservation-cycle --project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]")
	.description("Reserve a set of file paths and optionally release them at the end of the workflow.")
	.usage("--project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--paths <paths:value1,value2>", "Set paths. (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--ttl-seconds <ttl-seconds:number>", "Set ttl_seconds. (default: 3600; example: 3600)", (value) => parseFloat(value))
	.option("--exclusive <exclusive:true|false>", "Set exclusive. (default: true; example: true)", (value) => value !== 'false')
	.option("--reason <reason>", "Set reason. (default: macro-file_reservation; example: macro-file_reservation)")
	.option("--auto-release <auto-release:true|false>", "Set auto_release. (default: false; example: false)", (value) => value !== 'false')
	
	.alias("macro_file_reservation_cycle")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.paths !== undefined) args.paths = cmdOpts.paths;
		if (cmdOpts.ttlSeconds !== undefined) args.ttl_seconds = cmdOpts.ttlSeconds;
		if (cmdOpts.exclusive !== undefined) args.exclusive = cmdOpts.exclusive;
		if (cmdOpts.reason !== undefined) args.reason = cmdOpts.reason;
		if (cmdOpts.autoRelease !== undefined) args.auto_release = cmdOpts.autoRelease;
			const call = (proxy.macroFileReservationCycle as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.macro_file_reservation_cycle(project_key: \"value\", ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): reason, auto_release" + '\n');

program
	.command("macro-contact-handshake")
	.summary("macro-contact-handshake --project-key <project-key> [--requester <requester>] [--target <target>] [--reason <reason>] [--ttl-seconds <ttl-seconds:number>] [--raw <json>]")
	.description("Request contact permissions and optionally auto-approve plus send a welcome message.")
	.usage("--project-key <project-key> [--requester <requester>] [--target <target>] [--reason <reason>] [--ttl-seconds <ttl-seconds:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.option("--requester <requester>", "Set requester. (default: null; example: null)")
	.option("--target <target>", "Set target. (default: null; example: null)")
	.option("--reason <reason>", "Set reason. (default: )")
	.option("--ttl-seconds <ttl-seconds:number>", "Set ttl_seconds. (default: 604800; example: 604800)", (value) => parseFloat(value))
	.option("--auto-accept <auto-accept:true|false>", "Set auto_accept. (default: false; example: false)", (value) => value !== 'false')
	.option("--welcome-subject <welcome-subject>", "Set welcome_subject. (default: null; example: null)")
	.option("--welcome-body <welcome-body>", "Set welcome_body. (default: null; example: null)")
	.option("--to-project <to-project>", "Set to_project. (default: null; example: null)")
	.option("--agent-name <agent-name>", "Set agent_name. (default: null; example: null)")
	.option("--to-agent <to-agent>", "Set to_agent. (default: null; example: null)")
	.option("--register-if-missing <register-if-missing:true|false>", "Set register_if_missing. (default: true; example: true)", (value) => value !== 'false')
	.option("--program <program>", "Set program. (default: null; example: null)")
	.option("--model <model>", "Set model. (default: null; example: null)")
	.option("--task-description <task-description>", "Set task_description. (default: null; example: null)")
	.option("--thread-id <thread-id>", "Set thread_id. (default: null; example: null)")
	
	.alias("macro_contact_handshake")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.requester !== undefined) args.requester = cmdOpts.requester;
		if (cmdOpts.target !== undefined) args.target = cmdOpts.target;
		if (cmdOpts.reason !== undefined) args.reason = cmdOpts.reason;
		if (cmdOpts.ttlSeconds !== undefined) args.ttl_seconds = cmdOpts.ttlSeconds;
		if (cmdOpts.autoAccept !== undefined) args.auto_accept = cmdOpts.autoAccept;
		if (cmdOpts.welcomeSubject !== undefined) args.welcome_subject = cmdOpts.welcomeSubject;
		if (cmdOpts.welcomeBody !== undefined) args.welcome_body = cmdOpts.welcomeBody;
		if (cmdOpts.toProject !== undefined) args.to_project = cmdOpts.toProject;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.toAgent !== undefined) args.to_agent = cmdOpts.toAgent;
		if (cmdOpts.registerIfMissing !== undefined) args.register_if_missing = cmdOpts.registerIfMissing;
		if (cmdOpts.program !== undefined) args.program = cmdOpts.program;
		if (cmdOpts.model !== undefined) args.model = cmdOpts.model;
		if (cmdOpts.taskDescription !== undefined) args.task_description = cmdOpts.taskDescription;
		if (cmdOpts.threadId !== undefined) args.thread_id = cmdOpts.threadId;
			const call = (proxy.macroContactHandshake as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.macro_contact_handshake(project_key: \"value\", req, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (11): auto_accept, welcome_subject, welcome_body, to_project, agent_name, ..." + '\n');

program
	.command("search-messages")
	.summary("search-messages --project-key <project-key> --query <query> [--limit <limit:number>] [--raw <json>]")
	.description("Full-text search over subject and body for a project.\n\nTips\n----\n- SQLite FTS5 syntax supported: phrases (\"build plan\"), prefix (mig*), boolean (plan AND users)\n- Results are ordered by bm25 score (best matches first)\n- Limit defaults to 20; raise for broad queries\n\nQuery examples\n---------------\n- Phrase search: `\"build plan\"`\n- Prefix: `migrat*`\n- Boolean: `plan AND users`\n- Require urgent: `urgent AND deployment`\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nquery : str\n    FTS5 query string.\nlimit : int\n    Max results to return.\n\nReturns\n-------\nlist[dict]\n    Each entry: { id, subject, importance, ack_required, created_ts, thread_id, from }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"10\",\"method\":\"tools/call\",\"params\":{\"name\":\"search_messages\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"query\":\"\"build plan\" AND users\", \"limit\": 50\n}}}\n```")
	.usage("--project-key <project-key> --query <query> [--limit <limit:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--query <query>", "Set query.")
	.option("--limit <limit:number>", "Set limit. (default: 20; example: 20)", (value) => parseFloat(value))
	
	.alias("search_messages")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.limit !== undefined) args.limit = cmdOpts.limit;
			const call = (proxy.searchMessages as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.search_messages(project_key: \"value\", query: \"val, ...)");

program
	.command("summarize-thread")
	.summary("summarize-thread --project-key <project-key> --thread-id <thread-id> [--include-examples <include-examples:true|false>] [--llm-mode <llm-mode:true|false>] [--llm-model <llm-model>] [--raw <json>]")
	.description("Extract participants, key points, and action items for one or more threads.\n\nSingle-thread mode (thread_id is a single ID):\n- Returns detailed summary with optional example messages\n- Response: { thread_id, summary: {participants[], key_points[], action_items[]}, examples[] }\n\nMulti-thread mode (thread_id is comma-separated IDs like \"TKT-1,TKT-2,TKT-3\"):\n- Returns aggregate digest across all threads\n- Response: { threads: [{thread_id, summary}], aggregate: {top_mentions[], key_points[], action_items[]} }\n\nParameters\n----------\nproject_key : str\n    Project identifier.\nthread_id : str\n    Single thread ID for detailed summary, OR comma-separated IDs for aggregate digest.\ninclude_examples : bool\n    If true (single-thread mode only), include up to 3 sample messages.\nllm_mode : bool\n    If true and LLM is enabled, refine the summary with AI.\nllm_model : Optional[str]\n    Override model name for the LLM call.\nper_thread_limit : int\n    Max messages to consider per thread (multi-thread mode).\n\nExamples\n--------\nSingle thread:\n```json\n{\"thread_id\": \"TKT-123\", \"include_examples\": true}\n```\n\nMultiple threads:\n```json\n{\"thread_id\": \"TKT-1,TKT-2,TKT-3\"}\n```")
	.usage("--project-key <project-key> --thread-id <thread-id> [--include-examples <include-examples:true|false>] [--llm-mode <llm-mode:true|false>] [--llm-model <llm-model>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--thread-id <thread-id>", "Set thread_id. (example: example-id)")
	.option("--include-examples <include-examples:true|false>", "Set include_examples. (default: false; example: false)", (value) => value !== 'false')
	.option("--llm-mode <llm-mode:true|false>", "Set llm_mode. (default: true; example: true)", (value) => value !== 'false')
	.option("--llm-model <llm-model>", "Set llm_model. (default: null; example: null)")
	.option("--per-thread-limit <per-thread-limit:number>", "Set per_thread_limit. (default: 50; example: 50)", (value) => parseFloat(value))
	
	.alias("summarize_thread")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.threadId !== undefined) args.thread_id = cmdOpts.threadId;
		if (cmdOpts.includeExamples !== undefined) args.include_examples = cmdOpts.includeExamples;
		if (cmdOpts.llmMode !== undefined) args.llm_mode = cmdOpts.llmMode;
		if (cmdOpts.llmModel !== undefined) args.llm_model = cmdOpts.llmModel;
		if (cmdOpts.perThreadLimit !== undefined) args.per_thread_limit = cmdOpts.perThreadLimit;
			const call = (proxy.summarizeThread as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.summarize_thread(project_key: \"value\", thread_id:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): per_thread_limit" + '\n');

program
	.command("install-precommit-guard")
	.summary("install-precommit-guard --project-key <project-key> --code-repo-path <code-repo-path> [--raw <json>]")
	.description("Invoke the install_precommit_guard tool.")
	.usage("--project-key <project-key> --code-repo-path <code-repo-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--code-repo-path <code-repo-path>", "Set code_repo_path. (example: /path/to/file.md)")
	
	.alias("install_precommit_guard")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.codeRepoPath !== undefined) args.code_repo_path = cmdOpts.codeRepoPath;
			const call = (proxy.installPrecommitGuard as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.install_precommit_guard(project_key: \"value\", cod, ...)");

program
	.command("uninstall-precommit-guard")
	.summary("uninstall-precommit-guard --code-repo-path <code-repo-path> [--raw <json>]")
	.description("Invoke the uninstall_precommit_guard tool.")
	.usage("--code-repo-path <code-repo-path> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--code-repo-path <code-repo-path>", "Set code_repo_path. (example: /path/to/file.md)")
	
	.alias("uninstall_precommit_guard")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.codeRepoPath !== undefined) args.code_repo_path = cmdOpts.codeRepoPath;
			const call = (proxy.uninstallPrecommitGuard as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.uninstall_precommit_guard(code_repo_path: \"/path/, ...)");

program
	.command("file-reservation-paths")
	.summary("file-reservation-paths --project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]")
	.description("Request advisory file reservations (leases) on project-relative paths/globs.\n\nSemantics\n---------\n- Conflicts are reported if an overlapping active exclusive reservation exists held by another agent\n- Glob matching is symmetric (`fnmatchcase(a,b)` or `fnmatchcase(b,a)`), including exact matches\n- When granted, a JSON artifact is written under `file_reservations/<sha1(path)>.json` and the DB is updated\n- TTL must be >= 60 seconds (enforced by the server settings/policy)\n\nDo / Don't\n----------\nDo:\n- Reserve files before starting edits to signal intent to other agents.\n- Use specific, minimal patterns (e.g., `app/api/*.py`) instead of broad globs.\n- Set a realistic TTL and renew with `renew_file_reservations` if you need more time.\n\nDon't:\n- Reserve the entire repository or very broad patterns (e.g., `**/*`) unless absolutely necessary.\n- Hold long-lived exclusive reservations when you are not actively editing.\n- Ignore conflicts; resolve them by coordinating with holders or waiting for expiry.\n\nParameters\n----------\nproject_key : str\nagent_name : str\npaths : list[str]\n    File paths or glob patterns relative to the project workspace (e.g., \"app/api/*.py\").\nttl_seconds : int\n    Time to live for the file_reservation; expired file_reservations are auto-released.\nexclusive : bool\n    If true, exclusive intent; otherwise shared/observe-only.\nreason : str\n    Optional explanation (helps humans reviewing Git artifacts).\n\nReturns\n-------\ndict\n    { granted: [{id, path_pattern, exclusive, reason, expires_ts}], conflicts: [{path, holders: [...]}] }\n\nExample\n-------\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"12\",\"method\":\"tools/call\",\"params\":{\"name\":\"file_reservation_paths\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\",\"paths\":[\"app/api/*.py\"],\n  \"ttl_seconds\":7200,\"exclusive\":true,\"reason\":\"migrations\"\n}}}\n```")
	.usage("--project-key <project-key> --agent-name <agent-name> --paths <paths:value1,value2> [--ttl-seconds <ttl-seconds:number>] [--exclusive <exclusive:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--paths <paths:value1,value2>", "Set paths. (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--ttl-seconds <ttl-seconds:number>", "Set ttl_seconds. (default: 3600; example: 3600)", (value) => parseFloat(value))
	.option("--exclusive <exclusive:true|false>", "Set exclusive. (default: true; example: true)", (value) => value !== 'false')
	.option("--reason <reason>", "Set reason. (default: )")
	
	.alias("file_reservation_paths")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.paths !== undefined) args.paths = cmdOpts.paths;
		if (cmdOpts.ttlSeconds !== undefined) args.ttl_seconds = cmdOpts.ttlSeconds;
		if (cmdOpts.exclusive !== undefined) args.exclusive = cmdOpts.exclusive;
		if (cmdOpts.reason !== undefined) args.reason = cmdOpts.reason;
			const call = (proxy.fileReservationPaths as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.file_reservation_paths(project_key: \"value\", agen, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (1): reason" + '\n');

program
	.command("release-file-reservations")
	.summary("release-file-reservations --project-key <project-key> --agent-name <agent-name> [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]")
	.description("Release active file reservations held by an agent.\n\nBehavior\n--------\n- If both `paths` and `file_reservation_ids` are omitted, all active reservations for the agent are released\n- Otherwise, restricts release to matching ids and/or path patterns\n- JSON artifacts stay in Git for audit; DB records get `released_ts`\n\nReturns\n-------\ndict\n    { released: int, released_at: iso8601 }\n\nIdempotency\n-----------\n- Safe to call repeatedly. Releasing an already-released (or non-existent) reservation is a no-op.\n\nExamples\n--------\nRelease all active reservations for agent:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"13\",\"method\":\"tools/call\",\"params\":{\"name\":\"release_file_reservations\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\"\n}}}\n```\n\nRelease by ids:\n```json\n{\"jsonrpc\":\"2.0\",\"id\":\"14\",\"method\":\"tools/call\",\"params\":{\"name\":\"release_file_reservations\",\"arguments\":{\n  \"project_key\":\"/abs/path/backend\",\"agent_name\":\"GreenCastle\",\"file_reservation_ids\":[101,102]\n}}}\n```")
	.usage("--project-key <project-key> --agent-name <agent-name> [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.option("--paths <paths>", "Set paths. (default: null; example: null)")
	.option("--file-reservation-ids <file-reservation-ids>", "Set file_reservation_ids. (default: null; example: null)")
	
	.alias("release_file_reservations")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.paths !== undefined) args.paths = cmdOpts.paths;
		if (cmdOpts.fileReservationIds !== undefined) args.file_reservation_ids = cmdOpts.fileReservationIds;
			const call = (proxy.releaseFileReservations as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.release_file_reservations(project_key: \"value\", a, ...)");

program
	.command("force-release-file-reservation")
	.summary("force-release-file-reservation --project-key <project-key> --agent-name <agent-name> --file-reservation-id <file-reservation-id:number> [--notify-previous <notify-previous:true|false>] [--note <note>] [--raw <json>]")
	.description("Force-release a stale file reservation held by another agent after inactivity heuristics.\n\nThe tool validates that the reservation appears abandoned (agent inactive beyond threshold and\nno recent mail/filesystem/git activity). When released, an optional notification is sent to the\nprevious holder summarizing the heuristics.")
	.usage("--project-key <project-key> --agent-name <agent-name> --file-reservation-id <file-reservation-id:number> [--notify-previous <notify-previous:true|false>] [--note <note>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.requiredOption("--file-reservation-id <file-reservation-id:number>", "Set file_reservation_id. (example: 1)", (value) => parseFloat(value))
	.option("--notify-previous <notify-previous:true|false>", "Set notify_previous. (default: true; example: true)", (value) => value !== 'false')
	.option("--note <note>", "Set note. (default: )")
	
	.alias("force_release_file_reservation")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.fileReservationId !== undefined) args.file_reservation_id = cmdOpts.fileReservationId;
		if (cmdOpts.notifyPrevious !== undefined) args.notify_previous = cmdOpts.notifyPrevious;
		if (cmdOpts.note !== undefined) args.note = cmdOpts.note;
			const call = (proxy.forceReleaseFileReservation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.force_release_file_reservation(project_key: \"valu, ...)");

program
	.command("renew-file-reservations")
	.summary("renew-file-reservations --project-key <project-key> --agent-name <agent-name> [--extend-seconds <extend-seconds:number>] [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]")
	.description("Extend expiry for active file reservations held by an agent without reissuing them.\n\nParameters\n----------\nproject_key : str\n    Project slug or human key.\nagent_name : str\n    Agent identity who owns the reservations.\nextend_seconds : int\n    Seconds to extend from the later of now or current expiry (min 60s).\npaths : Optional[list[str]]\n    Restrict renewals to matching path patterns.\nfile_reservation_ids : Optional[list[int]]\n    Restrict renewals to matching reservation ids.\n\nReturns\n-------\ndict\n    { renewed: int, file_reservations: [{id, path_pattern, old_expires_ts, new_expires_ts}] }")
	.usage("--project-key <project-key> --agent-name <agent-name> [--extend-seconds <extend-seconds:number>] [--paths <paths>] [--file-reservation-ids <file-reservation-ids>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--project-key <project-key>", "Set project_key.")
	.requiredOption("--agent-name <agent-name>", "Set agent_name.")
	.option("--extend-seconds <extend-seconds:number>", "Set extend_seconds. (default: 1800; example: 1800)", (value) => parseFloat(value))
	.option("--paths <paths>", "Set paths. (default: null; example: null)")
	.option("--file-reservation-ids <file-reservation-ids>", "Set file_reservation_ids. (default: null; example: null)")
	
	.alias("renew_file_reservations")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.projectKey !== undefined) args.project_key = cmdOpts.projectKey;
		if (cmdOpts.agentName !== undefined) args.agent_name = cmdOpts.agentName;
		if (cmdOpts.extendSeconds !== undefined) args.extend_seconds = cmdOpts.extendSeconds;
		if (cmdOpts.paths !== undefined) args.paths = cmdOpts.paths;
		if (cmdOpts.fileReservationIds !== undefined) args.file_reservation_ids = cmdOpts.fileReservationIds;
			const call = (proxy.renewFileReservations as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call agent-mail.renew_file_reservations(project_key: \"value\", age, ...)");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('— ' + embeddedDescription);
	const plainTitle = embeddedName + ' — ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
