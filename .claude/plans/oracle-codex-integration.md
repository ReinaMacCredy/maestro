# Oracle Codex Integration

_Generated by Claude (PHASE: REVISE)_

## Context

### Original Request
Update the oracle agent to use Codex (GPT-5.2) for enhanced analysis, replacing Claude Opus with Codex 5.2

### Domain
REFACTOR - Modify existing oracle agent to support Codex integration

### Technical Decisions
- **Model**: Replace Claude Opus with gpt-5.2-codex (xhigh reasoning effort)
- **Trigger**: User choice at invocation - offer "Standard (Opus)" vs "Enhanced (Codex)" when @oracle is used
- **NO Fallback**: Codex only - fail if unavailable (explicitly rejected Claude fallback)
- **Integration**: Reuse existing codex-cli.sh script
- **Output Location**: `.atlas/codex/results/oracle-{timestamp}.md` (reuse codex directory with oracle- prefix per Metis resolution)
- **Handoff Format**: Similar to prometheus Codex handoffs in `.atlas/oracle/handoffs/`
- **Return Format**: JSON with file path + summary extract: `{"file": "...", "summary": "..."}`
- **Scope**: Multiple files - keyword detector, oracle wrapper script, directory structure

### Requirements
**MUST HAVE**:
- Modify @oracle keyword handler to offer standard vs Codex choice
- Create oracle handoff format for Codex (similar to plan handoffs)
- Integrate with codex-cli.sh for execution
- Store Codex oracle results in `.atlas/codex/results/` with `oracle-` prefix
- Return JSON with file path + summary to calling context

**EXCLUDED**:
- Claude Opus fallback (explicitly rejected)
- Creating separate agent file (reuse existing atlas-oracle.md)
- Complex caching mechanisms
- Modifying atlas-oracle.md agent prompt

---

## Work Objectives

### Core Objective
Enable the @oracle keyword to offer users a choice between standard oracle (Claude Opus) and enhanced oracle (Codex 5.2), with Codex integration using existing codex-cli.sh infrastructure, outputting to `.atlas/codex/results/oracle-{timestamp}.md`.

### Concrete Deliverables
- Modified `scripts/keyword-detector.sh` with @oracle choice prompt (outputs addToPrompt JSON with instructions for main context to invoke AskUserQuestion)
- New wrapper script: `scripts/oracle-codex.sh`
- Directory structure: `.atlas/oracle/handoffs/` only (results go to `.atlas/codex/results/`)
- Oracle handoff template format (reference: `.atlas/codex/handoffs/*.md`)
- Updated CLAUDE.md documentation

### Definition of Done
- [ ] User invokes @oracle → choice prompt appears → Bash: `echo "@oracle test question" | ./scripts/keyword-detector.sh`
- [ ] Standard choice spawns atlas-oracle subagent (existing behavior)
- [ ] Codex choice creates handoff → runs oracle-codex.sh → returns JSON with file + summary
- [ ] Results saved to `.atlas/codex/results/oracle-{timestamp}.md`
- [ ] CLAUDE.md reflects new oracle modes

### Must Have
- User choice mechanism via addToPrompt JSON (keyword-detector.sh outputs JSON containing instructions for main context to invoke AskUserQuestion, similar to generator-choice-handler.sh pattern)
- Codex handoff template (Markdown format, reference: `.atlas/codex/handoffs/*.md` existing handoffs)
- oracle-codex.sh wrapper script (calls codex-cli.sh with oracle context, writes to `.atlas/codex/results/oracle-{timestamp}.md`)
- Background execution with polling (reference: `skills/atlas/references/agents/atlas-prometheus.md` lines showing background Bash + TaskOutput polling)
- Return value format: JSON with `{"file": "...", "summary": "..."}` where summary is "Bottom line" section or first 500 chars
- Directory creation for `.atlas/oracle/handoffs/`

### Must NOT Have (Guardrails)
- NO fallback to Claude Opus if Codex fails
- NO modification to atlas-oracle.md agent prompt
- NO caching or persistence of Codex results beyond output file
- NO breaking changes to existing @oracle behavior when standard mode chosen

---

## Prerequisites

### Dependencies
- Existing `scripts/codex-cli.sh` (verified: exists)
- Existing `scripts/lib/hook-common.sh` (for keyword detector)
- Codex CLI installed (`codex` command available)
- jq (for JSON processing)

### Required Knowledge
- How prometheus uses Codex (handoff → codex-cli.sh → poll → merge) - reference: `skills/atlas/references/agents/atlas-prometheus.md` lines 200-250 showing background execution + TaskOutput polling
- Keyword detector pattern (lines 99-106 for @oracle)
- Codex CLI usage: `codex exec --full-auto --skip-git-repo-check -c model=gpt-5.2-codex ...`
- Hook choice mechanism: keyword-detector.sh outputs addToPrompt JSON containing instructions for main context to invoke AskUserQuestion (reference: `hooks/scripts/generator-choice-handler.sh` pattern)

### Environment Setup
```bash
# Verify codex CLI available
which codex  # Should return path to codex executable

# Verify jq
which jq

# Create oracle handoff directory only
mkdir -p .atlas/oracle/handoffs
```

---

## Verification Strategy

### Test Decision
- **Infrastructure exists**: YES (Task* tools, pytest)
- **User wants tests**: Manual verification (no unit tests for hook scripts currently)
- **Framework**: Manual testing via bash commands
- **Coverage Goals**: N/A for hook scripts

### Manual QA Procedures

| Type | Verification | Procedure |
|------|--------------|-----------|
| **Keyword Detection** | Terminal session | `echo "@oracle architectural question" \| ./scripts/keyword-detector.sh` → Verify choice prompt in output |
| **Codex Integration** | Background task | Run oracle-codex.sh → Poll with TaskOutput → Verify result file created in `.atlas/codex/results/oracle-*.md` |
| **Standard Mode** | Subagent spawn | Choose "Standard" → Verify atlas-oracle subagent spawned with Task tool |
| **Output Format** | File inspection | Check `.atlas/codex/results/oracle-*.md` exists and contains Markdown |
| **Return JSON** | JSON parsing | Verify oracle-codex.sh returns `{"file": "...", "summary": "..."}` format |

---

## Task Flow

```
Task 1 (Create handoff directory)
  ↓
Task 2 (Create oracle-codex.sh)
  ↓
Task 3 (Modify keyword-detector.sh)
  ↓
Task 4 (Update CLAUDE.md)
  ↓
Task 5 (Manual verification)
```

## Parallelization

| Group | Tasks | Reason |
|-------|-------|--------|
| A | 1, 2 | Independent - dir creation + script creation |
| B | 3 | Depends on 2 (references oracle-codex.sh) |
| C | 4 | Depends on 3 (documents final behavior) |

---

## TODOs

### Task 1: Create Oracle Handoff Directory

- [ ] 1. Create directory structure for oracle handoffs only

  **What to do**:
  - Create `.atlas/oracle/handoffs/` directory (results will use existing `.atlas/codex/results/`)
  - Add `.gitkeep` file to ensure directory is tracked
  - Do NOT create separate results directory (reuse `.atlas/codex/results/` with oracle- prefix)

  **Must NOT do**:
  - Don't create `.atlas/oracle/results/` (use `.atlas/codex/results/` instead per Metis resolution)
  - Don't create files with actual data yet (just structure)

  **Complexity**: 2/10
  **Location**: `.atlas/oracle/handoffs/` (new directory)
  **Dependencies**: None
  **Parallelizable**: YES (with Task 2) - completely independent

  **Manual Verification**:
  - Step 1: Run `ls -la .atlas/oracle/`
  - Step 2: Verify `handoffs/` subdirectory exists
  - Step 3: Verify `.atlas/codex/results/` already exists (no need to create)
  - Expected: Handoff directory created with .gitkeep file

  **References**:
  **Pattern References**:
  - `.atlas/codex/handoffs/` - Similar directory pattern for Codex handoffs
  - `.atlas/codex/results/` - Existing output directory (will be reused with oracle- prefix)

  **Acceptance Criteria**:
  - [ ] `.atlas/oracle/handoffs/` exists - command: `test -d .atlas/oracle/handoffs && echo OK`
  - [ ] `.gitkeep` file present - command: `test -f .atlas/oracle/handoffs/.gitkeep && echo OK`
  - [ ] `.atlas/codex/results/` already exists - command: `test -d .atlas/codex/results && echo OK`

  **Commit**: YES
  - Message: `feat(oracle): create handoff directory for Codex integration`
  - Files: `.atlas/oracle/handoffs/.gitkeep`

  **Rollback Strategy**:
  ```bash
  git revert <commit-hash>
  # Manual: rm -rf .atlas/oracle
  ```

---

### Task 2: Create oracle-codex.sh Wrapper Script

- [ ] 2. Create oracle-codex.sh wrapper script with JSON return format

  **What to do**:
  - Create `scripts/oracle-codex.sh` (new file)
  - Accept two arguments: `$1` = user question, `$2` = context (optional)
  - Generate handoff Markdown with:
    - User's question verbatim
    - Context section (if provided)
    - Oracle instructions (from atlas-oracle.md decision framework)
    - Timestamp for file naming
  - Write handoff to `.atlas/oracle/handoffs/{timestamp}.md`
  - Call `codex-cli.sh` with handoff file path and output name
  - Write result to `.atlas/codex/results/oracle-{timestamp}.md` (NOT `.atlas/oracle/results/`)
  - Extract summary (either "Bottom line" section if present, or first 500 chars)
  - Return JSON to stdout: `{"file": "/absolute/path/to/result.md", "summary": "extracted summary..."}`

  **Must NOT do**:
  - Don't modify codex-cli.sh (reuse as-is)
  - Don't add fallback logic (Codex-only)
  - Don't implement caching
  - Don't write to `.atlas/oracle/results/` (use `.atlas/codex/results/oracle-*` instead)
  - Don't return only file path (must include summary in JSON)

  **Complexity**: 6/10
  **Location**: `scripts/oracle-codex.sh` (new file, ~100 lines)
  **Dependencies**: None
  **Parallelizable**: YES (with Task 1) - doesn't depend on directories existing yet

  **Manual Verification**:
  - Step 1: Run `./scripts/oracle-codex.sh "What's the best architecture for X?" "Context: existing codebase"`
  - Step 2: Verify handoff created in `.atlas/oracle/handoffs/`
  - Step 3: Verify result created in `.atlas/codex/results/oracle-*.md`
  - Step 4: Verify JSON output contains both `file` and `summary` keys
  - Expected: Script exits 0, JSON with file path + summary printed to stdout

  **References**:
  **Pattern References**:
  - `scripts/codex-cli.sh:1-76` - Codex CLI invocation pattern (use as template)
  - `skills/atlas/references/agents/atlas-prometheus.md:200-250` - Background execution + TaskOutput polling pattern
  - `.atlas/codex/handoffs/sisyphus-to-atlas-migration.md` - Example handoff structure with section headers
  - `scripts/lib/hook-common.sh` - Shared bash utilities

  **API/Type References**:
  - Input: `$1` = question (string), `$2` = context (optional string)
  - Output: stdout = JSON string: `{"file": "/path/to/result", "summary": "text..."}`
  - Exit codes: 0=success, 1=missing args, 2=codex unavailable, 4=codex failed

  **Acceptance Criteria**:
  - [ ] Script accepts question argument - command: `./scripts/oracle-codex.sh "test" && echo OK`
  - [ ] Handoff written to `.atlas/oracle/handoffs/` - command: `ls .atlas/oracle/handoffs/*.md | wc -l`
  - [ ] Result written to `.atlas/codex/results/oracle-*.md` - command: `./scripts/oracle-codex.sh "test" && ls .atlas/codex/results/oracle-*.md`
  - [ ] Calls codex-cli.sh successfully - command: `grep -q "codex-cli.sh" scripts/oracle-codex.sh`
  - [ ] Returns JSON with file + summary - command: `./scripts/oracle-codex.sh "test" | jq -r '.file, .summary'`

  **Commit**: YES
  - Message: `feat(oracle): add oracle-codex.sh wrapper with JSON return format`
  - Files: `scripts/oracle-codex.sh`

  **Rollback Strategy**:
  ```bash
  git revert <commit-hash>
  # Manual: rm scripts/oracle-codex.sh
  ```

---

### Task 3: Modify keyword-detector.sh for Oracle Choice

- [ ] 3. Modify keyword-detector.sh to offer standard vs Codex choice via addToPrompt

  **What to do**:
  - Replace lines 99-106 (@oracle case) in `scripts/keyword-detector.sh`
  - Change from single "addToPrompt" to user choice mechanism
  - Output addToPrompt JSON containing instructions for main context to invoke AskUserQuestion
  - Option 1: Standard Oracle (Claude Opus) → spawn atlas-oracle subagent
  - Option 2: Enhanced Oracle (Codex 5.2) → call oracle-codex.sh in background + poll
  - Use generator-choice-handler.sh pattern as reference for how to structure the choice instructions

  **Must NOT do**:
  - Don't break existing @oracle behavior for standard mode
  - Don't add complexity beyond two choices
  - Don't hardcode choice (must be user-selectable)
  - Don't try to invoke AskUserQuestion directly from hook (hooks can't call tools - must output addToPrompt with instructions)

  **Complexity**: 6/10
  **Location**: `scripts/keyword-detector.sh:99-106` (modify existing)
  **Dependencies**: Task 2 (references oracle-codex.sh script)
  **Parallelizable**: NO (depends on Task 2) - needs oracle-codex.sh to exist

  **Manual Verification**:
  - Step 1: Run `echo "@oracle question" | ./scripts/keyword-detector.sh`
  - Step 2: Verify JSON output contains addToPrompt with choice instructions
  - Step 3: Manually test standard mode → verify atlas-oracle spawned
  - Step 4: Manually test Codex mode → verify oracle-codex.sh called
  - Expected: Choice mechanism works, both modes functional

  **References**:
  **Pattern References**:
  - `scripts/keyword-detector.sh:99-106` - Current @oracle implementation
  - `scripts/keyword-detector.sh:163-172` - @atlas-plan pattern (shows command routing)
  - `hooks/scripts/generator-choice-handler.sh` - How to structure addToPrompt JSON for main context to invoke AskUserQuestion

  **API/Type References**:
  - Hook output format: `{ "addToPrompt": "..." }` JSON
  - addToPrompt content: Instructions for main context to invoke AskUserQuestion with two options

  **Acceptance Criteria**:
  - [ ] @oracle triggers choice prompt - command: `echo "@oracle test" | ./scripts/keyword-detector.sh | jq -r .addToPrompt | grep -i "choice"`
  - [ ] Standard mode delegates to atlas-oracle - verify JSON addToPrompt contains "Task" + "atlas-oracle"
  - [ ] Codex mode calls oracle-codex.sh - verify JSON addToPrompt contains "oracle-codex.sh"
  - [ ] No breaking changes to standard mode - test existing @oracle behavior

  **Commit**: YES
  - Message: `feat(oracle): add standard vs Codex choice to @oracle keyword`
  - Files: `scripts/keyword-detector.sh`

  **Rollback Strategy**:
  ```bash
  git revert <commit-hash>
  # Manual: Restore original @oracle case from git history
  ```

---

### Task 4: Update CLAUDE.md Documentation

- [ ] 4. Update CLAUDE.md with oracle Codex integration

  **What to do**:
  - Add section under "Keywords" table explaining @oracle now has two modes
  - Document standard vs Codex choice
  - Add entry to "Scripts" section for oracle-codex.sh
  - Note exit codes and usage
  - Update "Architecture" section to mention oracle Codex integration
  - Document output location: `.atlas/codex/results/oracle-*.md`
  - Document return format: JSON with file + summary

  **Must NOT do**:
  - Don't document implementation details (keep user-facing)
  - Don't add excessive examples (concise docs)

  **Complexity**: 3/10
  **Location**: `CLAUDE.md` (update existing sections)
  **Dependencies**: Task 3 (documents final behavior)
  **Parallelizable**: NO (depends on Task 3) - needs final implementation to document

  **Manual Verification**:
  - Step 1: Read `CLAUDE.md` and verify @oracle section updated
  - Step 2: Verify scripts section includes oracle-codex.sh
  - Step 3: Verify output location documented as `.atlas/codex/results/oracle-*.md`
  - Expected: Documentation reflects new oracle modes accurately

  **References**:
  **Pattern References**:
  - `CLAUDE.md:78-97` - Keywords table (update @oracle entry)
  - `CLAUDE.md:147-159` - Scripts section (add oracle-codex.sh)

  **Acceptance Criteria**:
  - [ ] @oracle keyword documented with modes - command: `grep -A 3 "@oracle" CLAUDE.md | grep -i "codex"`
  - [ ] oracle-codex.sh in scripts section - command: `grep "oracle-codex.sh" CLAUDE.md`
  - [ ] Exit codes documented - command: `grep -A 5 "oracle-codex.sh" CLAUDE.md | grep "exit"`
  - [ ] Output location documented - command: `grep "codex/results/oracle" CLAUDE.md`

  **Commit**: YES
  - Message: `docs(oracle): document Codex integration and dual-mode behavior`
  - Files: `CLAUDE.md`

  **Rollback Strategy**:
  ```bash
  git revert <commit-hash>
  # Manual: Remove oracle-codex.sh references from CLAUDE.md
  ```

---

### Task 5: Manual End-to-End Verification

- [ ] 5. Perform manual end-to-end verification of oracle Codex integration

  **What to do**:
  - Test standard oracle mode: invoke @oracle with test question → verify atlas-oracle spawned
  - Test Codex oracle mode: invoke @oracle with test question → choose Codex → verify handoff created → verify result returned with JSON format
  - Test error handling: invoke Codex mode without codex CLI installed → verify graceful failure
  - Verify directory structure: check `.atlas/oracle/handoffs/` exists, results go to `.atlas/codex/results/oracle-*.md`
  - Verify return JSON contains both file path and summary
  - Document any issues found

  **Must NOT do**:
  - Don't skip error case testing
  - Don't assume success without verification

  **Complexity**: 4/10
  **Location**: Manual testing (no file changes)
  **Dependencies**: Task 1, 2, 3, 4 (all previous tasks)
  **Parallelizable**: NO (depends on all previous tasks) - final integration test

  **Manual Verification**:
  - Step 1: Run `echo "@oracle What architecture pattern should I use for async processing?" | ./scripts/keyword-detector.sh`
  - Step 2: Choose standard mode → verify Task(subagent_type='atlas-oracle') spawned
  - Step 3: Choose Codex mode → verify oracle-codex.sh executed → check `.atlas/codex/results/oracle-*.md` for output
  - Step 4: Verify JSON return format contains file + summary
  - Step 5: Test error case → rename `codex` binary → run Codex mode → verify error handling
  - Expected: All modes work as designed, error handling graceful, JSON format correct

  **References**:
  **Pattern References**:
  - Prometheus Codex integration workflow (similar testing pattern)
  - `skills/atlas/references/agents/atlas-prometheus.md` - Background execution + polling reference

  **Acceptance Criteria**:
  - [ ] Standard mode works - spawn atlas-oracle successfully
  - [ ] Codex mode works - handoff created, result returned to `.atlas/codex/results/oracle-*.md`
  - [ ] JSON format correct - contains both `file` and `summary` keys
  - [ ] Error handling works - codex unavailable → clear error message
  - [ ] Documentation accurate - CLAUDE.md matches actual behavior

  **Commit**: NO (manual testing only)

  **Rollback Strategy**:
  N/A (no code changes)

---

## Commit Strategy

| After Task | Message | Files | Verification |
|------------|---------|-------|--------------|
| 1 | `feat(oracle): create handoff directory for Codex integration` | `.atlas/oracle/handoffs/.gitkeep` | `test -d .atlas/oracle/handoffs` |
| 2 | `feat(oracle): add oracle-codex.sh wrapper with JSON return format` | `scripts/oracle-codex.sh` | `./scripts/oracle-codex.sh "test" \| jq -r .file` |
| 3 | `feat(oracle): add standard vs Codex choice to @oracle keyword` | `scripts/keyword-detector.sh` | `echo "@oracle test" \| ./scripts/keyword-detector.sh` |
| 4 | `docs(oracle): document Codex integration and dual-mode behavior` | `CLAUDE.md` | `grep "oracle-codex" CLAUDE.md` |

---

## Risks & Mitigation

| Risk | Severity | Probability | Mitigation |
|------|----------|-------------|------------|
| Codex CLI unavailable at runtime | HIGH | MEDIUM | Clear error message, document prerequisite in CLAUDE.md |
| Hook output format incompatible with choice mechanism | MEDIUM | LOW | Use addToPrompt with instructions for main context (reference generator-choice-handler.sh pattern) |
| Breaking existing @oracle behavior | HIGH | LOW | Test standard mode thoroughly before committing, rollback plan ready |
| Codex API rate limits | MEDIUM | MEDIUM | Document expected rate limits, suggest users check OpenAI dashboard |
| Directory mismatch causing confusion | LOW | MEDIUM | Clear documentation: handoffs in `.atlas/oracle/`, results in `.atlas/codex/results/oracle-*` |

---

## Rollback Plan

### Per-Task Rollback

Each task commit can be reverted independently:

| Task | Rollback Command | Manual Steps |
|------|------------------|--------------|
| 1 | `git revert <commit>` | `rm -rf .atlas/oracle` |
| 2 | `git revert <commit>` | `rm scripts/oracle-codex.sh` |
| 3 | `git revert <commit>` | Restore `scripts/keyword-detector.sh:99-106` from git history |
| 4 | `git revert <commit>` | Remove oracle-codex.sh references from CLAUDE.md |

### Complete Rollback

If implementation fails catastrophically:

```bash
# Identify last good state
git log --oneline

# Revert to previous state
git reset --hard <good-commit>

# Or revert specific commits in reverse order
git revert <task-4-commit> <task-3-commit> <task-2-commit> <task-1-commit>
```

### Cleanup Commands

```bash
# Remove generated files
rm -rf .atlas/oracle

# Remove script
rm scripts/oracle-codex.sh

# Restore keyword detector
git checkout HEAD -- scripts/keyword-detector.sh CLAUDE.md
```

---

## Success Criteria

### Verification Commands
```bash
# Test standard oracle mode
echo "@oracle test question" | ./scripts/keyword-detector.sh | jq -r .addToPrompt

# Test Codex oracle mode
./scripts/oracle-codex.sh "What's the best architecture for async processing?"

# Verify directory structure
ls -la .atlas/oracle/handoffs/
ls -la .atlas/codex/results/oracle-*.md

# Verify JSON return format
./scripts/oracle-codex.sh "test" | jq '.file, .summary'

# Verify documentation
grep -A 5 "@oracle" CLAUDE.md
```

### Final Checklist
- [ ] All "Must Have" requirements present
- [ ] All "Must NOT Have" guardrails enforced
- [ ] Standard oracle mode unchanged (backwards compatible)
- [ ] Codex mode functional with handoff → execution → result to `.atlas/codex/results/oracle-*.md`
- [ ] Return format is JSON with file + summary
- [ ] Error handling graceful (Codex unavailable case)
- [ ] Documentation accurate and complete

---

## Codex Enhancements

_Enhanced by Codex (gpt-5.2-codex with xhigh reasoning)_

### Edge Case Handling (Task 2: scripts/oracle-codex.sh)

1. **Empty/whitespace guard**: Add validation for empty input
   ```bash
   if [ -z "$(printf '%s' "$QUESTION" | tr -d '[:space:]')" ]; then
     echo "[ERROR] Empty oracle question" >&2
     exit 1
   fi
   ```
   Verify: `./scripts/oracle-codex.sh "" 2>err; echo $?; rg "Empty oracle question" err`

2. **Size guard rails**: Limit input to 10K chars to reduce memory usage
   ```bash
   MAX_QUESTION_CHARS=10000
   QUESTION_SAFE=$(printf '%s' "$QUESTION" | head -c "$MAX_QUESTION_CHARS")
   ```
   Extract summary via streaming with fallback:
   ```bash
   SUMMARY=$(awk '/^## *Bottom line/{found=1; next} found{print; exit}' "$RESULT_FILE")
   [ -z "$SUMMARY" ] && SUMMARY=$(head -c 500 "$RESULT_FILE")
   ```
   Verify: `QUESTION=$(perl -e 'print "a"x11001'); ./scripts/oracle-codex.sh "$QUESTION" 2>/dev/null; rg "truncated from" .atlas/oracle/handoffs/*.md`

3. **Special character preservation**: Use printf instead of echo -e
   ```bash
   printf '%s\n' "$QUESTION" >> "$HANDOFF_FILE"
   printf '%s\n' "$CONTEXT" >> "$HANDOFF_FILE"
   # Emit JSON safely with jq
   jq -Rn --arg file "$RESULT_FILE" --arg summary "$SUMMARY" '{file:$file, summary:$summary}'
   ```
   Verify: `QUESTION=$(printf 'line1\nline2 "quote" \\ backslash'); ./scripts/oracle-codex.sh "$QUESTION" | jq -e .summary`

4. **Timeout watchdog**: Handle network stalls with configurable timeout
   ```bash
   ORACLE_CODEX_TIMEOUT_SECS=${ORACLE_CODEX_TIMEOUT_SECS:-1200}
   # Exit 5 on timeout
   ```
   Verify: `ORACLE_CODEX_TIMEOUT_SECS=1 ./scripts/oracle-codex.sh "timeout test"; echo $?`

5. **Concurrency-safe filenames**: Use mktemp for parallel runs
   ```bash
   HANDOFF_FILE=$(mktemp ".atlas/oracle/handoffs/oracle-${timestamp}-XXXXXX.md")
   RESULT_FILE=$(mktemp ".atlas/codex/results/oracle-${timestamp}-XXXXXX.md")
   ```
   Verify: `./scripts/oracle-codex.sh "q1" & ./scripts/oracle-codex.sh "q2" & wait; ls .atlas/codex/results/oracle-*.md`

### Security Hardening (Tasks 2 and 3)

1. **Disable globbing**: Prevent glob expansion in user input
   ```bash
   set -f  # Disable globbing
   printf '%s\n' "$QUESTION"  # No eval/word splitting
   ```
   Verify: `QUESTION='*?[abc]'; ./scripts/oracle-codex.sh "$QUESTION" 2>/dev/null; rg "\\*\\?\\[abc\\]" .atlas/oracle/handoffs/*.md`

2. **Safe file naming**: Fixed directories, no user input in paths
   ```bash
   HANDOFF_FILE=$(mktemp ".atlas/oracle/handoffs/oracle-${timestamp}-XXXXXX.md")
   RESULT_FILE=$(mktemp ".atlas/codex/results/oracle-${timestamp}-XXXXXX.md")
   ```
   Verify: `./scripts/oracle-codex.sh "test" 2>/dev/null; ls .atlas/oracle/handoffs/oracle-*.md`

3. **Sensitive data protection**: Restrictive permissions + optional redaction
   ```bash
   umask 077  # Only owner can read/write
   # Optional redaction when ORACLE_REDACT=1
   redact_sensitive() { sed -E 's/(api_key|token|secret|password)=[^[:space:]]*/\1=REDACTED/gi'; }
   ```
   Verify: `ORACLE_REDACT=1 ./scripts/oracle-codex.sh "test" "API_KEY=sekrit" 2>/dev/null; rg "REDACTED" .atlas/oracle/handoffs/*.md`

4. **JSON injection prevention** (Task 3): Escape user text in addToPrompt
   ```bash
   # In scripts/keyword-detector.sh:99-105
   ESCAPED_QUESTION=$(escape_for_json "$QUESTION")
   ```
   Verify: `echo '@oracle "}\n' | ./scripts/keyword-detector.sh | jq -e .addToPrompt`

### Enhanced Error Handling (Task 2: scripts/oracle-codex.sh)

1. **Exit code semantics**: Consistent exit codes with die() helper
   - 0 = success
   - 1 = input error (empty question)
   - 2 = codex CLI missing
   - 3 = I/O failure (handoff write failed)
   - 4 = codex execution failed
   - 5 = timeout
   ```bash
   die() { echo "[ERROR] $1" >&2; exit "$2"; }
   ```
   Verify: `./scripts/oracle-codex.sh "" >/dev/null 2>err; echo $?; rg "Empty oracle question" err`

2. **Preflight codex check**: Verify codex before calling codex-cli.sh
   ```bash
   command -v codex >/dev/null 2>&1 || die "Codex CLI not installed" 2
   ```
   Verify: `PATH="/usr/bin:/bin" ./scripts/oracle-codex.sh "test" 2>err; echo $?; rg "Codex CLI not installed" err`

3. **File I/O validation**: Check file creation succeeded
   ```bash
   [ -s "$HANDOFF_FILE" ] || die "Handoff write failed" 3
   [ -s "$RESULT_FILE" ] || die "Result file missing" 4
   ```
   Verify: `chmod -w .atlas/oracle/handoffs; ./scripts/oracle-codex.sh "test" 2>err; echo $?; rg "Handoff write failed" err`

4. **Cleanup on failure**: Remove partial artifacts with trap
   ```bash
   success=0
   cleanup() { [ "$success" -eq 0 ] && rm -f "$HANDOFF_FILE" "$RESULT_FILE"; }
   trap cleanup EXIT
   ```
   Verify: `before=$(ls .atlas/oracle/handoffs | wc -l); ORACLE_CODEX_TIMEOUT_SECS=1 ./scripts/oracle-codex.sh "timeout" 2>/dev/null; after=$(ls .atlas/oracle/handoffs | wc -l); test "$before" -eq "$after"`

### Testing Recommendations (Task 5: Manual end-to-end verification)

| Test Case | Verification Command |
|-----------|---------------------|
| Choice prompt shows both modes | `echo "@oracle question" \| ./scripts/keyword-detector.sh \| jq -r .addToPrompt \| rg -i "Standard\|Enhanced\|oracle-codex.sh"` |
| Codex missing error (exit 2) | `PATH="/usr/bin:/bin" ./scripts/oracle-codex.sh "test" 2>err; echo $?; rg "Codex CLI not installed" err` |
| Timeout exits 5 with cleanup | `before=$(ls .atlas/oracle/handoffs \| wc -l); ORACLE_CODEX_TIMEOUT_SECS=1 ./scripts/oracle-codex.sh "timeout" 2>/dev/null; echo $?; after=$(ls .atlas/oracle/handoffs \| wc -l); test "$before" -eq "$after"` |
| Large input truncated | `LONG=$(perl -e 'print "a"x11001'); ./scripts/oracle-codex.sh "$LONG" & ./scripts/oracle-codex.sh "$LONG" & wait; rg "truncated from" .atlas/oracle/handoffs/*.md` |
| Special chars in JSON | `QUESTION=$(printf 'line1\nline2 "quote" \\ backslash'); ./scripts/oracle-codex.sh "$QUESTION" \| jq -e .file` |

### Documentation Additions (Task 4: CLAUDE.md)

1. **Agent table entry** (CLAUDE.md:55-65): Update `atlas-oracle` model note
   - From: `opus`
   - To: `opus (standard) / gpt-5.2-codex (enhanced via oracle-codex.sh)`
   Verify: `rg -n "atlas-oracle" CLAUDE.md`

2. **Keyword table expansion** (CLAUDE.md:116-119): Add @oracle modes
   - Standard vs Enhanced (Codex) prompt
   - Expected latency: 10-15 min for Codex mode
   - Output location: `.atlas/codex/results/oracle-*.md`
   Verify: `rg -n "@oracle" CLAUDE.md`

3. **Scripts section** (CLAUDE.md:171-184): Add oracle-codex.sh entry
   - Usage: `./scripts/oracle-codex.sh "<question>" ["<context>"]`
   - Exit codes: 0=success, 1=input, 2=codex missing, 3=I/O, 4=codex failed, 5=timeout
   - Returns: JSON `{"file": "...", "summary": "..."}`
   Verify: `rg -n "oracle-codex.sh" CLAUDE.md`

4. **Runtime configuration**: Document environment variables
   - `ORACLE_CODEX_TIMEOUT_SECS` (default: 1200)
   - `ORACLE_REDACT` (set to 1 for sensitive data redaction)
   Verify: `rg -n "ORACLE_CODEX_TIMEOUT_SECS|ORACLE_REDACT" CLAUDE.md`

### Assumptions

- `scripts/codex-cli.sh` behavior remains as currently documented
- `codex` CLI is installed unless testing error paths
- `escape_for_json` from `scripts/lib/hook-common.sh` remains available for Task 3 updates
